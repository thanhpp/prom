// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/thanhpp/prom/pkg/usrmanrpc/usrmanService.proto

package usrmanrpc

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	entity "github.com/thanhpp/prom/cmd/usrman/repository/entity"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GetUserByIDReq struct {
	UserID uint32 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
}

func (m *GetUserByIDReq) Reset()         { *m = GetUserByIDReq{} }
func (m *GetUserByIDReq) String() string { return proto.CompactTextString(m) }
func (*GetUserByIDReq) ProtoMessage()    {}
func (*GetUserByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{0}
}
func (m *GetUserByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserByIDReq.Merge(m, src)
}
func (m *GetUserByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *GetUserByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserByIDReq proto.InternalMessageInfo

func (m *GetUserByIDReq) GetUserID() uint32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

type GetUserByIDResp struct {
	Code    int32        `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string       `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	User    *entity.User `protobuf:"bytes,3,opt,name=User,proto3" json:"User,omitempty"`
}

func (m *GetUserByIDResp) Reset()         { *m = GetUserByIDResp{} }
func (m *GetUserByIDResp) String() string { return proto.CompactTextString(m) }
func (*GetUserByIDResp) ProtoMessage()    {}
func (*GetUserByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{1}
}
func (m *GetUserByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserByIDResp.Merge(m, src)
}
func (m *GetUserByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *GetUserByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserByIDResp proto.InternalMessageInfo

func (m *GetUserByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetUserByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetUserByIDResp) GetUser() *entity.User {
	if m != nil {
		return m.User
	}
	return nil
}

type CreateUserReq struct {
	User *entity.User `protobuf:"bytes,1,opt,name=User,proto3" json:"User,omitempty"`
}

func (m *CreateUserReq) Reset()         { *m = CreateUserReq{} }
func (m *CreateUserReq) String() string { return proto.CompactTextString(m) }
func (*CreateUserReq) ProtoMessage()    {}
func (*CreateUserReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{2}
}
func (m *CreateUserReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateUserReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateUserReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateUserReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateUserReq.Merge(m, src)
}
func (m *CreateUserReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateUserReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateUserReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateUserReq proto.InternalMessageInfo

func (m *CreateUserReq) GetUser() *entity.User {
	if m != nil {
		return m.User
	}
	return nil
}

type CreateUserResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *CreateUserResp) Reset()         { *m = CreateUserResp{} }
func (m *CreateUserResp) String() string { return proto.CompactTextString(m) }
func (*CreateUserResp) ProtoMessage()    {}
func (*CreateUserResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{3}
}
func (m *CreateUserResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateUserResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateUserResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateUserResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateUserResp.Merge(m, src)
}
func (m *CreateUserResp) XXX_Size() int {
	return m.Size()
}
func (m *CreateUserResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateUserResp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateUserResp proto.InternalMessageInfo

func (m *CreateUserResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CreateUserResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type GetUserByUsernamePassReq struct {
	Username string `protobuf:"bytes,1,opt,name=Username,proto3" json:"Username,omitempty"`
	Pass     string `protobuf:"bytes,2,opt,name=Pass,proto3" json:"Pass,omitempty"`
}

func (m *GetUserByUsernamePassReq) Reset()         { *m = GetUserByUsernamePassReq{} }
func (m *GetUserByUsernamePassReq) String() string { return proto.CompactTextString(m) }
func (*GetUserByUsernamePassReq) ProtoMessage()    {}
func (*GetUserByUsernamePassReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{4}
}
func (m *GetUserByUsernamePassReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserByUsernamePassReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserByUsernamePassReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserByUsernamePassReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserByUsernamePassReq.Merge(m, src)
}
func (m *GetUserByUsernamePassReq) XXX_Size() int {
	return m.Size()
}
func (m *GetUserByUsernamePassReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserByUsernamePassReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserByUsernamePassReq proto.InternalMessageInfo

func (m *GetUserByUsernamePassReq) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GetUserByUsernamePassReq) GetPass() string {
	if m != nil {
		return m.Pass
	}
	return ""
}

type GetUserByUsernamePassResp struct {
	Code    int32        `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string       `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	User    *entity.User `protobuf:"bytes,3,opt,name=User,proto3" json:"User,omitempty"`
}

func (m *GetUserByUsernamePassResp) Reset()         { *m = GetUserByUsernamePassResp{} }
func (m *GetUserByUsernamePassResp) String() string { return proto.CompactTextString(m) }
func (*GetUserByUsernamePassResp) ProtoMessage()    {}
func (*GetUserByUsernamePassResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{5}
}
func (m *GetUserByUsernamePassResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserByUsernamePassResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserByUsernamePassResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserByUsernamePassResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserByUsernamePassResp.Merge(m, src)
}
func (m *GetUserByUsernamePassResp) XXX_Size() int {
	return m.Size()
}
func (m *GetUserByUsernamePassResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserByUsernamePassResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserByUsernamePassResp proto.InternalMessageInfo

func (m *GetUserByUsernamePassResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetUserByUsernamePassResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetUserByUsernamePassResp) GetUser() *entity.User {
	if m != nil {
		return m.User
	}
	return nil
}

type GetUserByTeamIDReq struct {
	TeamID uint32 `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
}

func (m *GetUserByTeamIDReq) Reset()         { *m = GetUserByTeamIDReq{} }
func (m *GetUserByTeamIDReq) String() string { return proto.CompactTextString(m) }
func (*GetUserByTeamIDReq) ProtoMessage()    {}
func (*GetUserByTeamIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{6}
}
func (m *GetUserByTeamIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserByTeamIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserByTeamIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserByTeamIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserByTeamIDReq.Merge(m, src)
}
func (m *GetUserByTeamIDReq) XXX_Size() int {
	return m.Size()
}
func (m *GetUserByTeamIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserByTeamIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserByTeamIDReq proto.InternalMessageInfo

func (m *GetUserByTeamIDReq) GetTeamID() uint32 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

type GetUserByTeamIDResp struct {
	Code    int32          `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string         `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Users   []*entity.User `protobuf:"bytes,3,rep,name=Users,proto3" json:"Users,omitempty"`
}

func (m *GetUserByTeamIDResp) Reset()         { *m = GetUserByTeamIDResp{} }
func (m *GetUserByTeamIDResp) String() string { return proto.CompactTextString(m) }
func (*GetUserByTeamIDResp) ProtoMessage()    {}
func (*GetUserByTeamIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{7}
}
func (m *GetUserByTeamIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserByTeamIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserByTeamIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserByTeamIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserByTeamIDResp.Merge(m, src)
}
func (m *GetUserByTeamIDResp) XXX_Size() int {
	return m.Size()
}
func (m *GetUserByTeamIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserByTeamIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserByTeamIDResp proto.InternalMessageInfo

func (m *GetUserByTeamIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetUserByTeamIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetUserByTeamIDResp) GetUsers() []*entity.User {
	if m != nil {
		return m.Users
	}
	return nil
}

type UpdateUserByIDReq struct {
	UserID uint32       `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	User   *entity.User `protobuf:"bytes,2,opt,name=User,proto3" json:"User,omitempty"`
}

func (m *UpdateUserByIDReq) Reset()         { *m = UpdateUserByIDReq{} }
func (m *UpdateUserByIDReq) String() string { return proto.CompactTextString(m) }
func (*UpdateUserByIDReq) ProtoMessage()    {}
func (*UpdateUserByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{8}
}
func (m *UpdateUserByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUserByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUserByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateUserByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUserByIDReq.Merge(m, src)
}
func (m *UpdateUserByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUserByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUserByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUserByIDReq proto.InternalMessageInfo

func (m *UpdateUserByIDReq) GetUserID() uint32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateUserByIDReq) GetUser() *entity.User {
	if m != nil {
		return m.User
	}
	return nil
}

type UpdateUserByIDResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *UpdateUserByIDResp) Reset()         { *m = UpdateUserByIDResp{} }
func (m *UpdateUserByIDResp) String() string { return proto.CompactTextString(m) }
func (*UpdateUserByIDResp) ProtoMessage()    {}
func (*UpdateUserByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{9}
}
func (m *UpdateUserByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUserByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUserByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateUserByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUserByIDResp.Merge(m, src)
}
func (m *UpdateUserByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUserByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUserByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUserByIDResp proto.InternalMessageInfo

func (m *UpdateUserByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *UpdateUserByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type DeleteUserByIDReq struct {
	UserID uint32 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
}

func (m *DeleteUserByIDReq) Reset()         { *m = DeleteUserByIDReq{} }
func (m *DeleteUserByIDReq) String() string { return proto.CompactTextString(m) }
func (*DeleteUserByIDReq) ProtoMessage()    {}
func (*DeleteUserByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{10}
}
func (m *DeleteUserByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteUserByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteUserByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteUserByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteUserByIDReq.Merge(m, src)
}
func (m *DeleteUserByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteUserByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteUserByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteUserByIDReq proto.InternalMessageInfo

func (m *DeleteUserByIDReq) GetUserID() uint32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

type DeleteUserByIDResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *DeleteUserByIDResp) Reset()         { *m = DeleteUserByIDResp{} }
func (m *DeleteUserByIDResp) String() string { return proto.CompactTextString(m) }
func (*DeleteUserByIDResp) ProtoMessage()    {}
func (*DeleteUserByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{11}
}
func (m *DeleteUserByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteUserByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteUserByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteUserByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteUserByIDResp.Merge(m, src)
}
func (m *DeleteUserByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *DeleteUserByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteUserByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteUserByIDResp proto.InternalMessageInfo

func (m *DeleteUserByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DeleteUserByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type CreateTeamReq struct {
	Team *entity.Team `protobuf:"bytes,1,opt,name=Team,proto3" json:"Team,omitempty"`
}

func (m *CreateTeamReq) Reset()         { *m = CreateTeamReq{} }
func (m *CreateTeamReq) String() string { return proto.CompactTextString(m) }
func (*CreateTeamReq) ProtoMessage()    {}
func (*CreateTeamReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{12}
}
func (m *CreateTeamReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTeamReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTeamReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTeamReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTeamReq.Merge(m, src)
}
func (m *CreateTeamReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateTeamReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTeamReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTeamReq proto.InternalMessageInfo

func (m *CreateTeamReq) GetTeam() *entity.Team {
	if m != nil {
		return m.Team
	}
	return nil
}

type CreateTeamResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *CreateTeamResp) Reset()         { *m = CreateTeamResp{} }
func (m *CreateTeamResp) String() string { return proto.CompactTextString(m) }
func (*CreateTeamResp) ProtoMessage()    {}
func (*CreateTeamResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{13}
}
func (m *CreateTeamResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTeamResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTeamResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTeamResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTeamResp.Merge(m, src)
}
func (m *CreateTeamResp) XXX_Size() int {
	return m.Size()
}
func (m *CreateTeamResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTeamResp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTeamResp proto.InternalMessageInfo

func (m *CreateTeamResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CreateTeamResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type GetTeamByIDReq struct {
	TeamID uint32 `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
}

func (m *GetTeamByIDReq) Reset()         { *m = GetTeamByIDReq{} }
func (m *GetTeamByIDReq) String() string { return proto.CompactTextString(m) }
func (*GetTeamByIDReq) ProtoMessage()    {}
func (*GetTeamByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{14}
}
func (m *GetTeamByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTeamByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTeamByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTeamByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTeamByIDReq.Merge(m, src)
}
func (m *GetTeamByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *GetTeamByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTeamByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetTeamByIDReq proto.InternalMessageInfo

func (m *GetTeamByIDReq) GetTeamID() uint32 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

type GetTeamByIDResp struct {
	Code    int32        `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string       `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Team    *entity.Team `protobuf:"bytes,3,opt,name=Team,proto3" json:"Team,omitempty"`
}

func (m *GetTeamByIDResp) Reset()         { *m = GetTeamByIDResp{} }
func (m *GetTeamByIDResp) String() string { return proto.CompactTextString(m) }
func (*GetTeamByIDResp) ProtoMessage()    {}
func (*GetTeamByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{15}
}
func (m *GetTeamByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTeamByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTeamByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTeamByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTeamByIDResp.Merge(m, src)
}
func (m *GetTeamByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *GetTeamByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTeamByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetTeamByIDResp proto.InternalMessageInfo

func (m *GetTeamByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetTeamByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetTeamByIDResp) GetTeam() *entity.Team {
	if m != nil {
		return m.Team
	}
	return nil
}

type GetTeamsByCreatorIDReq struct {
	CreatorID uint32 `protobuf:"varint,1,opt,name=CreatorID,proto3" json:"CreatorID,omitempty"`
}

func (m *GetTeamsByCreatorIDReq) Reset()         { *m = GetTeamsByCreatorIDReq{} }
func (m *GetTeamsByCreatorIDReq) String() string { return proto.CompactTextString(m) }
func (*GetTeamsByCreatorIDReq) ProtoMessage()    {}
func (*GetTeamsByCreatorIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{16}
}
func (m *GetTeamsByCreatorIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTeamsByCreatorIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTeamsByCreatorIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTeamsByCreatorIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTeamsByCreatorIDReq.Merge(m, src)
}
func (m *GetTeamsByCreatorIDReq) XXX_Size() int {
	return m.Size()
}
func (m *GetTeamsByCreatorIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTeamsByCreatorIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetTeamsByCreatorIDReq proto.InternalMessageInfo

func (m *GetTeamsByCreatorIDReq) GetCreatorID() uint32 {
	if m != nil {
		return m.CreatorID
	}
	return 0
}

type GetTeamsByCreatorIDResp struct {
	Code    int32          `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string         `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Teams   []*entity.Team `protobuf:"bytes,3,rep,name=Teams,proto3" json:"Teams,omitempty"`
}

func (m *GetTeamsByCreatorIDResp) Reset()         { *m = GetTeamsByCreatorIDResp{} }
func (m *GetTeamsByCreatorIDResp) String() string { return proto.CompactTextString(m) }
func (*GetTeamsByCreatorIDResp) ProtoMessage()    {}
func (*GetTeamsByCreatorIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{17}
}
func (m *GetTeamsByCreatorIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTeamsByCreatorIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTeamsByCreatorIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTeamsByCreatorIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTeamsByCreatorIDResp.Merge(m, src)
}
func (m *GetTeamsByCreatorIDResp) XXX_Size() int {
	return m.Size()
}
func (m *GetTeamsByCreatorIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTeamsByCreatorIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetTeamsByCreatorIDResp proto.InternalMessageInfo

func (m *GetTeamsByCreatorIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetTeamsByCreatorIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetTeamsByCreatorIDResp) GetTeams() []*entity.Team {
	if m != nil {
		return m.Teams
	}
	return nil
}

type GetTeamByNameReq struct {
	TeamName string `protobuf:"bytes,1,opt,name=TeamName,proto3" json:"TeamName,omitempty"`
}

func (m *GetTeamByNameReq) Reset()         { *m = GetTeamByNameReq{} }
func (m *GetTeamByNameReq) String() string { return proto.CompactTextString(m) }
func (*GetTeamByNameReq) ProtoMessage()    {}
func (*GetTeamByNameReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{18}
}
func (m *GetTeamByNameReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTeamByNameReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTeamByNameReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTeamByNameReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTeamByNameReq.Merge(m, src)
}
func (m *GetTeamByNameReq) XXX_Size() int {
	return m.Size()
}
func (m *GetTeamByNameReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTeamByNameReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetTeamByNameReq proto.InternalMessageInfo

func (m *GetTeamByNameReq) GetTeamName() string {
	if m != nil {
		return m.TeamName
	}
	return ""
}

type GetTeamByNameResp struct {
	Code    int32          `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string         `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Teams   []*entity.Team `protobuf:"bytes,3,rep,name=Teams,proto3" json:"Teams,omitempty"`
}

func (m *GetTeamByNameResp) Reset()         { *m = GetTeamByNameResp{} }
func (m *GetTeamByNameResp) String() string { return proto.CompactTextString(m) }
func (*GetTeamByNameResp) ProtoMessage()    {}
func (*GetTeamByNameResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{19}
}
func (m *GetTeamByNameResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTeamByNameResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTeamByNameResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTeamByNameResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTeamByNameResp.Merge(m, src)
}
func (m *GetTeamByNameResp) XXX_Size() int {
	return m.Size()
}
func (m *GetTeamByNameResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTeamByNameResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetTeamByNameResp proto.InternalMessageInfo

func (m *GetTeamByNameResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetTeamByNameResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetTeamByNameResp) GetTeams() []*entity.Team {
	if m != nil {
		return m.Teams
	}
	return nil
}

type UpdateTeamByIDReq struct {
	TeamID uint32       `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	Team   *entity.Team `protobuf:"bytes,2,opt,name=Team,proto3" json:"Team,omitempty"`
}

func (m *UpdateTeamByIDReq) Reset()         { *m = UpdateTeamByIDReq{} }
func (m *UpdateTeamByIDReq) String() string { return proto.CompactTextString(m) }
func (*UpdateTeamByIDReq) ProtoMessage()    {}
func (*UpdateTeamByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{20}
}
func (m *UpdateTeamByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTeamByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTeamByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTeamByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTeamByIDReq.Merge(m, src)
}
func (m *UpdateTeamByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTeamByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTeamByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTeamByIDReq proto.InternalMessageInfo

func (m *UpdateTeamByIDReq) GetTeamID() uint32 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateTeamByIDReq) GetTeam() *entity.Team {
	if m != nil {
		return m.Team
	}
	return nil
}

type UpdateTeamByIDResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *UpdateTeamByIDResp) Reset()         { *m = UpdateTeamByIDResp{} }
func (m *UpdateTeamByIDResp) String() string { return proto.CompactTextString(m) }
func (*UpdateTeamByIDResp) ProtoMessage()    {}
func (*UpdateTeamByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{21}
}
func (m *UpdateTeamByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTeamByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTeamByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTeamByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTeamByIDResp.Merge(m, src)
}
func (m *UpdateTeamByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTeamByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTeamByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTeamByIDResp proto.InternalMessageInfo

func (m *UpdateTeamByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *UpdateTeamByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type AddMemberByIDReq struct {
	TeamID uint32 `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	UserID uint32 `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
}

func (m *AddMemberByIDReq) Reset()         { *m = AddMemberByIDReq{} }
func (m *AddMemberByIDReq) String() string { return proto.CompactTextString(m) }
func (*AddMemberByIDReq) ProtoMessage()    {}
func (*AddMemberByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{22}
}
func (m *AddMemberByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMemberByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMemberByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMemberByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMemberByIDReq.Merge(m, src)
}
func (m *AddMemberByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *AddMemberByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMemberByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddMemberByIDReq proto.InternalMessageInfo

func (m *AddMemberByIDReq) GetTeamID() uint32 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *AddMemberByIDReq) GetUserID() uint32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

type AddMemberByIDResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *AddMemberByIDResp) Reset()         { *m = AddMemberByIDResp{} }
func (m *AddMemberByIDResp) String() string { return proto.CompactTextString(m) }
func (*AddMemberByIDResp) ProtoMessage()    {}
func (*AddMemberByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{23}
}
func (m *AddMemberByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMemberByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMemberByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMemberByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMemberByIDResp.Merge(m, src)
}
func (m *AddMemberByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *AddMemberByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMemberByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_AddMemberByIDResp proto.InternalMessageInfo

func (m *AddMemberByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *AddMemberByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type RemoveMemberByIDReq struct {
	TeamID uint32 `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	UserID uint32 `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
}

func (m *RemoveMemberByIDReq) Reset()         { *m = RemoveMemberByIDReq{} }
func (m *RemoveMemberByIDReq) String() string { return proto.CompactTextString(m) }
func (*RemoveMemberByIDReq) ProtoMessage()    {}
func (*RemoveMemberByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{24}
}
func (m *RemoveMemberByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveMemberByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveMemberByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveMemberByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveMemberByIDReq.Merge(m, src)
}
func (m *RemoveMemberByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *RemoveMemberByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveMemberByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveMemberByIDReq proto.InternalMessageInfo

func (m *RemoveMemberByIDReq) GetTeamID() uint32 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *RemoveMemberByIDReq) GetUserID() uint32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

type RemoveMemberByIDResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *RemoveMemberByIDResp) Reset()         { *m = RemoveMemberByIDResp{} }
func (m *RemoveMemberByIDResp) String() string { return proto.CompactTextString(m) }
func (*RemoveMemberByIDResp) ProtoMessage()    {}
func (*RemoveMemberByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{25}
}
func (m *RemoveMemberByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveMemberByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveMemberByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveMemberByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveMemberByIDResp.Merge(m, src)
}
func (m *RemoveMemberByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *RemoveMemberByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveMemberByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveMemberByIDResp proto.InternalMessageInfo

func (m *RemoveMemberByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RemoveMemberByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type DeleteTeamByIDReq struct {
	TeamID uint32 `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
}

func (m *DeleteTeamByIDReq) Reset()         { *m = DeleteTeamByIDReq{} }
func (m *DeleteTeamByIDReq) String() string { return proto.CompactTextString(m) }
func (*DeleteTeamByIDReq) ProtoMessage()    {}
func (*DeleteTeamByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{26}
}
func (m *DeleteTeamByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteTeamByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteTeamByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteTeamByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteTeamByIDReq.Merge(m, src)
}
func (m *DeleteTeamByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteTeamByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteTeamByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteTeamByIDReq proto.InternalMessageInfo

func (m *DeleteTeamByIDReq) GetTeamID() uint32 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

type DeleteTeamByIDResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *DeleteTeamByIDResp) Reset()         { *m = DeleteTeamByIDResp{} }
func (m *DeleteTeamByIDResp) String() string { return proto.CompactTextString(m) }
func (*DeleteTeamByIDResp) ProtoMessage()    {}
func (*DeleteTeamByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{27}
}
func (m *DeleteTeamByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteTeamByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteTeamByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteTeamByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteTeamByIDResp.Merge(m, src)
}
func (m *DeleteTeamByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *DeleteTeamByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteTeamByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteTeamByIDResp proto.InternalMessageInfo

func (m *DeleteTeamByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DeleteTeamByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type CreateProjectReq struct {
	Project *entity.Project `protobuf:"bytes,1,opt,name=Project,proto3" json:"Project,omitempty"`
}

func (m *CreateProjectReq) Reset()         { *m = CreateProjectReq{} }
func (m *CreateProjectReq) String() string { return proto.CompactTextString(m) }
func (*CreateProjectReq) ProtoMessage()    {}
func (*CreateProjectReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{28}
}
func (m *CreateProjectReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateProjectReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateProjectReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateProjectReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateProjectReq.Merge(m, src)
}
func (m *CreateProjectReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateProjectReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateProjectReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateProjectReq proto.InternalMessageInfo

func (m *CreateProjectReq) GetProject() *entity.Project {
	if m != nil {
		return m.Project
	}
	return nil
}

type CreateProjectResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *CreateProjectResp) Reset()         { *m = CreateProjectResp{} }
func (m *CreateProjectResp) String() string { return proto.CompactTextString(m) }
func (*CreateProjectResp) ProtoMessage()    {}
func (*CreateProjectResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{29}
}
func (m *CreateProjectResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateProjectResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateProjectResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateProjectResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateProjectResp.Merge(m, src)
}
func (m *CreateProjectResp) XXX_Size() int {
	return m.Size()
}
func (m *CreateProjectResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateProjectResp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateProjectResp proto.InternalMessageInfo

func (m *CreateProjectResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CreateProjectResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type GetProjectByIDReq struct {
	ProjectID uint32 `protobuf:"varint,1,opt,name=ProjectID,proto3" json:"ProjectID,omitempty"`
}

func (m *GetProjectByIDReq) Reset()         { *m = GetProjectByIDReq{} }
func (m *GetProjectByIDReq) String() string { return proto.CompactTextString(m) }
func (*GetProjectByIDReq) ProtoMessage()    {}
func (*GetProjectByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{30}
}
func (m *GetProjectByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetProjectByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetProjectByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetProjectByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetProjectByIDReq.Merge(m, src)
}
func (m *GetProjectByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *GetProjectByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetProjectByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetProjectByIDReq proto.InternalMessageInfo

func (m *GetProjectByIDReq) GetProjectID() uint32 {
	if m != nil {
		return m.ProjectID
	}
	return 0
}

type GetProjectByIDResp struct {
	Code    int32           `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string          `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Project *entity.Project `protobuf:"bytes,3,opt,name=Project,proto3" json:"Project,omitempty"`
}

func (m *GetProjectByIDResp) Reset()         { *m = GetProjectByIDResp{} }
func (m *GetProjectByIDResp) String() string { return proto.CompactTextString(m) }
func (*GetProjectByIDResp) ProtoMessage()    {}
func (*GetProjectByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{31}
}
func (m *GetProjectByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetProjectByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetProjectByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetProjectByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetProjectByIDResp.Merge(m, src)
}
func (m *GetProjectByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *GetProjectByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetProjectByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetProjectByIDResp proto.InternalMessageInfo

func (m *GetProjectByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetProjectByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetProjectByIDResp) GetProject() *entity.Project {
	if m != nil {
		return m.Project
	}
	return nil
}

type GetProjtectsByTeamIDReq struct {
	TeamID uint32 `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
}

func (m *GetProjtectsByTeamIDReq) Reset()         { *m = GetProjtectsByTeamIDReq{} }
func (m *GetProjtectsByTeamIDReq) String() string { return proto.CompactTextString(m) }
func (*GetProjtectsByTeamIDReq) ProtoMessage()    {}
func (*GetProjtectsByTeamIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{32}
}
func (m *GetProjtectsByTeamIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetProjtectsByTeamIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetProjtectsByTeamIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetProjtectsByTeamIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetProjtectsByTeamIDReq.Merge(m, src)
}
func (m *GetProjtectsByTeamIDReq) XXX_Size() int {
	return m.Size()
}
func (m *GetProjtectsByTeamIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetProjtectsByTeamIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetProjtectsByTeamIDReq proto.InternalMessageInfo

func (m *GetProjtectsByTeamIDReq) GetTeamID() uint32 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

type GetProjtectsByTeamIDResp struct {
	Code     int32             `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message  string            `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Projects []*entity.Project `protobuf:"bytes,3,rep,name=Projects,proto3" json:"Projects,omitempty"`
}

func (m *GetProjtectsByTeamIDResp) Reset()         { *m = GetProjtectsByTeamIDResp{} }
func (m *GetProjtectsByTeamIDResp) String() string { return proto.CompactTextString(m) }
func (*GetProjtectsByTeamIDResp) ProtoMessage()    {}
func (*GetProjtectsByTeamIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{33}
}
func (m *GetProjtectsByTeamIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetProjtectsByTeamIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetProjtectsByTeamIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetProjtectsByTeamIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetProjtectsByTeamIDResp.Merge(m, src)
}
func (m *GetProjtectsByTeamIDResp) XXX_Size() int {
	return m.Size()
}
func (m *GetProjtectsByTeamIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetProjtectsByTeamIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetProjtectsByTeamIDResp proto.InternalMessageInfo

func (m *GetProjtectsByTeamIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetProjtectsByTeamIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetProjtectsByTeamIDResp) GetProjects() []*entity.Project {
	if m != nil {
		return m.Projects
	}
	return nil
}

type UpdateProjectByIDReq struct {
	ProjectID uint32          `protobuf:"varint,1,opt,name=ProjectID,proto3" json:"ProjectID,omitempty"`
	Project   *entity.Project `protobuf:"bytes,2,opt,name=Project,proto3" json:"Project,omitempty"`
}

func (m *UpdateProjectByIDReq) Reset()         { *m = UpdateProjectByIDReq{} }
func (m *UpdateProjectByIDReq) String() string { return proto.CompactTextString(m) }
func (*UpdateProjectByIDReq) ProtoMessage()    {}
func (*UpdateProjectByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{34}
}
func (m *UpdateProjectByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateProjectByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateProjectByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateProjectByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateProjectByIDReq.Merge(m, src)
}
func (m *UpdateProjectByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateProjectByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateProjectByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateProjectByIDReq proto.InternalMessageInfo

func (m *UpdateProjectByIDReq) GetProjectID() uint32 {
	if m != nil {
		return m.ProjectID
	}
	return 0
}

func (m *UpdateProjectByIDReq) GetProject() *entity.Project {
	if m != nil {
		return m.Project
	}
	return nil
}

type UpdateProjectByIDResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *UpdateProjectByIDResp) Reset()         { *m = UpdateProjectByIDResp{} }
func (m *UpdateProjectByIDResp) String() string { return proto.CompactTextString(m) }
func (*UpdateProjectByIDResp) ProtoMessage()    {}
func (*UpdateProjectByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{35}
}
func (m *UpdateProjectByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateProjectByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateProjectByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateProjectByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateProjectByIDResp.Merge(m, src)
}
func (m *UpdateProjectByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *UpdateProjectByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateProjectByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateProjectByIDResp proto.InternalMessageInfo

func (m *UpdateProjectByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *UpdateProjectByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type DeleteProjectByIDReq struct {
	ProjectID uint32 `protobuf:"varint,1,opt,name=ProjectID,proto3" json:"ProjectID,omitempty"`
}

func (m *DeleteProjectByIDReq) Reset()         { *m = DeleteProjectByIDReq{} }
func (m *DeleteProjectByIDReq) String() string { return proto.CompactTextString(m) }
func (*DeleteProjectByIDReq) ProtoMessage()    {}
func (*DeleteProjectByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{36}
}
func (m *DeleteProjectByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteProjectByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteProjectByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteProjectByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteProjectByIDReq.Merge(m, src)
}
func (m *DeleteProjectByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteProjectByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteProjectByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteProjectByIDReq proto.InternalMessageInfo

func (m *DeleteProjectByIDReq) GetProjectID() uint32 {
	if m != nil {
		return m.ProjectID
	}
	return 0
}

type DeleteProjectByIDResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *DeleteProjectByIDResp) Reset()         { *m = DeleteProjectByIDResp{} }
func (m *DeleteProjectByIDResp) String() string { return proto.CompactTextString(m) }
func (*DeleteProjectByIDResp) ProtoMessage()    {}
func (*DeleteProjectByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1fdedd3c2808883, []int{37}
}
func (m *DeleteProjectByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteProjectByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteProjectByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteProjectByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteProjectByIDResp.Merge(m, src)
}
func (m *DeleteProjectByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *DeleteProjectByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteProjectByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteProjectByIDResp proto.InternalMessageInfo

func (m *DeleteProjectByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DeleteProjectByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*GetUserByIDReq)(nil), "usrmanrpc.GetUserByIDReq")
	proto.RegisterType((*GetUserByIDResp)(nil), "usrmanrpc.GetUserByIDResp")
	proto.RegisterType((*CreateUserReq)(nil), "usrmanrpc.CreateUserReq")
	proto.RegisterType((*CreateUserResp)(nil), "usrmanrpc.CreateUserResp")
	proto.RegisterType((*GetUserByUsernamePassReq)(nil), "usrmanrpc.GetUserByUsernamePassReq")
	proto.RegisterType((*GetUserByUsernamePassResp)(nil), "usrmanrpc.GetUserByUsernamePassResp")
	proto.RegisterType((*GetUserByTeamIDReq)(nil), "usrmanrpc.GetUserByTeamIDReq")
	proto.RegisterType((*GetUserByTeamIDResp)(nil), "usrmanrpc.GetUserByTeamIDResp")
	proto.RegisterType((*UpdateUserByIDReq)(nil), "usrmanrpc.UpdateUserByIDReq")
	proto.RegisterType((*UpdateUserByIDResp)(nil), "usrmanrpc.UpdateUserByIDResp")
	proto.RegisterType((*DeleteUserByIDReq)(nil), "usrmanrpc.DeleteUserByIDReq")
	proto.RegisterType((*DeleteUserByIDResp)(nil), "usrmanrpc.DeleteUserByIDResp")
	proto.RegisterType((*CreateTeamReq)(nil), "usrmanrpc.CreateTeamReq")
	proto.RegisterType((*CreateTeamResp)(nil), "usrmanrpc.CreateTeamResp")
	proto.RegisterType((*GetTeamByIDReq)(nil), "usrmanrpc.GetTeamByIDReq")
	proto.RegisterType((*GetTeamByIDResp)(nil), "usrmanrpc.GetTeamByIDResp")
	proto.RegisterType((*GetTeamsByCreatorIDReq)(nil), "usrmanrpc.GetTeamsByCreatorIDReq")
	proto.RegisterType((*GetTeamsByCreatorIDResp)(nil), "usrmanrpc.GetTeamsByCreatorIDResp")
	proto.RegisterType((*GetTeamByNameReq)(nil), "usrmanrpc.GetTeamByNameReq")
	proto.RegisterType((*GetTeamByNameResp)(nil), "usrmanrpc.GetTeamByNameResp")
	proto.RegisterType((*UpdateTeamByIDReq)(nil), "usrmanrpc.UpdateTeamByIDReq")
	proto.RegisterType((*UpdateTeamByIDResp)(nil), "usrmanrpc.UpdateTeamByIDResp")
	proto.RegisterType((*AddMemberByIDReq)(nil), "usrmanrpc.AddMemberByIDReq")
	proto.RegisterType((*AddMemberByIDResp)(nil), "usrmanrpc.AddMemberByIDResp")
	proto.RegisterType((*RemoveMemberByIDReq)(nil), "usrmanrpc.RemoveMemberByIDReq")
	proto.RegisterType((*RemoveMemberByIDResp)(nil), "usrmanrpc.RemoveMemberByIDResp")
	proto.RegisterType((*DeleteTeamByIDReq)(nil), "usrmanrpc.DeleteTeamByIDReq")
	proto.RegisterType((*DeleteTeamByIDResp)(nil), "usrmanrpc.DeleteTeamByIDResp")
	proto.RegisterType((*CreateProjectReq)(nil), "usrmanrpc.CreateProjectReq")
	proto.RegisterType((*CreateProjectResp)(nil), "usrmanrpc.CreateProjectResp")
	proto.RegisterType((*GetProjectByIDReq)(nil), "usrmanrpc.GetProjectByIDReq")
	proto.RegisterType((*GetProjectByIDResp)(nil), "usrmanrpc.GetProjectByIDResp")
	proto.RegisterType((*GetProjtectsByTeamIDReq)(nil), "usrmanrpc.GetProjtectsByTeamIDReq")
	proto.RegisterType((*GetProjtectsByTeamIDResp)(nil), "usrmanrpc.GetProjtectsByTeamIDResp")
	proto.RegisterType((*UpdateProjectByIDReq)(nil), "usrmanrpc.UpdateProjectByIDReq")
	proto.RegisterType((*UpdateProjectByIDResp)(nil), "usrmanrpc.UpdateProjectByIDResp")
	proto.RegisterType((*DeleteProjectByIDReq)(nil), "usrmanrpc.DeleteProjectByIDReq")
	proto.RegisterType((*DeleteProjectByIDResp)(nil), "usrmanrpc.DeleteProjectByIDResp")
}

func init() {
	proto.RegisterFile("github.com/thanhpp/prom/pkg/usrmanrpc/usrmanService.proto", fileDescriptor_e1fdedd3c2808883)
}

var fileDescriptor_e1fdedd3c2808883 = []byte{
	// 1042 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0xda, 0xfd, 0xe7, 0x57, 0x92, 0x26, 0xd3, 0xa4, 0x38, 0x4b, 0xb2, 0x35, 0x1b, 0x2a,
	0x45, 0xa2, 0xd8, 0x6a, 0x41, 0x08, 0x2e, 0x88, 0xb8, 0x8e, 0x50, 0x2b, 0xb9, 0x8a, 0x1c, 0x02,
	0x12, 0x42, 0x42, 0x6b, 0x7b, 0x70, 0x52, 0x58, 0xef, 0x76, 0x67, 0x13, 0x91, 0x2f, 0xc0, 0x99,
	0x8f, 0xc1, 0x47, 0xe0, 0xc8, 0x91, 0x63, 0x8f, 0x1c, 0x1b, 0xe7, 0x0b, 0x70, 0xe4, 0x58, 0xcd,
	0x9f, 0x1d, 0xcf, 0xcc, 0x4e, 0xd6, 0x5e, 0x57, 0xbd, 0x58, 0xfb, 0xe6, 0xfd, 0x99, 0xf7, 0xe6,
	0xfd, 0xfb, 0xc9, 0xf0, 0xe5, 0xe8, 0x24, 0x3d, 0x3e, 0xed, 0x37, 0x07, 0x51, 0xd8, 0x4a, 0x8f,
	0x83, 0xf1, 0x71, 0x1c, 0xb7, 0xe2, 0x24, 0x0a, 0x5b, 0xf1, 0x2f, 0xa3, 0xd6, 0x29, 0x49, 0xc2,
	0x60, 0x9c, 0xc4, 0x03, 0xf1, 0x75, 0x88, 0x93, 0xb3, 0x93, 0x01, 0x6e, 0xc6, 0x49, 0x94, 0x46,
	0xa8, 0x26, 0xd9, 0xee, 0x27, 0x8a, 0x95, 0x51, 0x34, 0x8a, 0x5a, 0x4c, 0xa2, 0x7f, 0xfa, 0x33,
	0xa3, 0x18, 0xc1, 0xbe, 0xb8, 0xa6, 0xfb, 0x45, 0x99, 0x4b, 0xf7, 0xc7, 0xe9, 0x49, 0x7a, 0xce,
	0x35, 0xfd, 0x5d, 0x58, 0xf9, 0x06, 0xa7, 0x47, 0x04, 0x27, 0xed, 0xf3, 0xa7, 0x9d, 0x1e, 0x7e,
	0x89, 0xee, 0xc1, 0x0d, 0x4a, 0x3e, 0xed, 0xd4, 0x9d, 0x86, 0xb3, 0xbb, 0xdc, 0x13, 0x94, 0x3f,
	0x84, 0x3b, 0x9a, 0x24, 0x89, 0x11, 0x82, 0x6b, 0x4f, 0xa2, 0x21, 0x66, 0x82, 0xd7, 0x7b, 0xec,
	0x1b, 0xd5, 0xe1, 0x66, 0x17, 0x13, 0x12, 0x8c, 0x70, 0xbd, 0xd2, 0x70, 0x76, 0x6b, 0xbd, 0x8c,
	0x44, 0x3b, 0x70, 0x8d, 0x6a, 0xd7, 0xab, 0x0d, 0x67, 0xf7, 0xf6, 0xe3, 0x3b, 0x4d, 0xe9, 0x57,
	0x93, 0x1e, 0xf7, 0x18, 0xd3, 0xff, 0x0c, 0x96, 0x9f, 0x24, 0x38, 0x48, 0x31, 0x3b, 0xc3, 0x2f,
	0xa5, 0x96, 0x53, 0xa4, 0xf5, 0x15, 0xac, 0xa8, 0x5a, 0x65, 0x5d, 0xf3, 0x9f, 0x41, 0x5d, 0xc6,
	0x46, 0x7f, 0xc7, 0x41, 0x88, 0x0f, 0x02, 0x42, 0xa8, 0x03, 0x2e, 0xdc, 0xca, 0x8e, 0x98, 0xb5,
	0x5a, 0x4f, 0xd2, 0xf4, 0x16, 0x2a, 0x26, 0xcc, 0xb1, 0x6f, 0x7f, 0x0c, 0x9b, 0x57, 0xd8, 0x7a,
	0x37, 0x2f, 0xf6, 0x10, 0x90, 0xbc, 0xef, 0x5b, 0x1c, 0x84, 0x32, 0x8b, 0x9c, 0xc8, 0xb2, 0xc8,
	0x29, 0xff, 0x05, 0xdc, 0xcd, 0x49, 0x97, 0xf6, 0xeb, 0x01, 0x5c, 0xa7, 0x16, 0x48, 0xbd, 0xda,
	0xa8, 0xda, 0x1c, 0xe3, 0x5c, 0xff, 0x00, 0xd6, 0x8e, 0xe2, 0xa1, 0xc8, 0xca, 0x8c, 0xf2, 0x92,
	0xb1, 0x56, 0x8a, 0x62, 0x6d, 0x03, 0x32, 0x2d, 0x96, 0xce, 0xf5, 0xc7, 0xb0, 0xd6, 0xc1, 0xbf,
	0xe2, 0xb9, 0xbc, 0xa2, 0x17, 0x9a, 0xc2, 0xa5, 0x2f, 0x94, 0x25, 0x4d, 0xdf, 0x5b, 0x94, 0x34,
	0xfd, 0xb4, 0x94, 0x34, 0x93, 0x60, 0xcc, 0x69, 0x49, 0x73, 0xad, 0xd2, 0xb7, 0xf2, 0xc6, 0xa6,
	0xca, 0x4a, 0x8c, 0xd6, 0x92, 0xe0, 0x8d, 0x3d, 0x95, 0x5c, 0xa4, 0x4c, 0x59, 0x3c, 0xd5, 0xa2,
	0x78, 0x3e, 0x87, 0x7b, 0xe2, 0x16, 0xd2, 0x3e, 0x67, 0x91, 0x45, 0x09, 0xf7, 0x6b, 0x0b, 0x6a,
	0x92, 0x16, 0xae, 0x4d, 0x0f, 0xfc, 0x31, 0xbc, 0x6f, 0xd5, 0x5b, 0xa4, 0x68, 0x99, 0x15, 0x4b,
	0xd1, 0x32, 0x37, 0x39, 0xd7, 0x6f, 0xc2, 0xaa, 0x7c, 0x8d, 0xe7, 0x41, 0x88, 0xc5, 0x08, 0xa0,
	0x07, 0xcf, 0x95, 0x11, 0x90, 0xd1, 0xfe, 0x31, 0xac, 0x19, 0xf2, 0xef, 0xca, 0x33, 0xd9, 0x4e,
	0x73, 0x24, 0x55, 0xe6, 0xa4, 0x52, 0x94, 0x13, 0xd9, 0x4e, 0x8b, 0x27, 0xdf, 0x6f, 0xc3, 0xea,
	0xde, 0x70, 0xd8, 0xc5, 0x61, 0x5f, 0xeb, 0x26, 0xab, 0x53, 0xd3, 0x2e, 0xab, 0x68, 0x5d, 0xb6,
	0x07, 0x6b, 0x86, 0x8d, 0xd2, 0x6e, 0xec, 0xc3, 0xdd, 0x1e, 0x0e, 0xa3, 0x33, 0xfc, 0x76, 0x9e,
	0x74, 0x60, 0x3d, 0x6f, 0x66, 0xf1, 0x11, 0x33, 0x4f, 0xfb, 0xc9, 0x11, 0xf3, 0x16, 0x49, 0xf8,
	0x1a, 0x56, 0xf9, 0xb0, 0x38, 0x48, 0xa2, 0x17, 0x78, 0x90, 0xd2, 0xfb, 0x1e, 0xc2, 0x4d, 0x41,
	0x89, 0x41, 0x83, 0x94, 0x22, 0xc8, 0xe4, 0x32, 0x11, 0x9a, 0x02, 0xc3, 0x42, 0x69, 0x27, 0x1e,
	0xb1, 0x4e, 0x10, 0xfa, 0x59, 0xd4, 0x5b, 0x50, 0x13, 0x27, 0xd3, 0xe6, 0x96, 0x07, 0x7e, 0xcc,
	0x76, 0x97, 0xa6, 0x52, 0xba, 0x7b, 0x94, 0x38, 0xab, 0xb3, 0xe3, 0x7c, 0xc4, 0xc6, 0x09, 0xa5,
	0x52, 0x3c, 0x48, 0xc9, 0x3c, 0x2b, 0xf3, 0x37, 0x06, 0x0e, 0x2c, 0x2a, 0xa5, 0x5d, 0x6d, 0xc2,
	0x2d, 0xe1, 0x47, 0xd6, 0xeb, 0x36, 0x5f, 0xa5, 0x8c, 0xdf, 0x87, 0x75, 0xde, 0x9f, 0x65, 0x1e,
	0x55, 0x7d, 0x90, 0xca, 0xec, 0x07, 0xd9, 0x87, 0x0d, 0xcb, 0x1d, 0x0b, 0x2c, 0xb9, 0x75, 0x5e,
	0xc5, 0xa5, 0xf2, 0xbf, 0x0f, 0x1b, 0x16, 0xad, 0xb2, 0x97, 0x3f, 0xfe, 0xfd, 0x3d, 0xa8, 0x1d,
	0x91, 0xa4, 0x1b, 0x8c, 0x0f, 0x93, 0x33, 0xd4, 0x81, 0xdb, 0x0a, 0x50, 0x45, 0x9b, 0x4a, 0xf4,
	0x3a, 0xd4, 0x75, 0xdd, 0xab, 0x58, 0x24, 0x46, 0x7b, 0x00, 0x53, 0x48, 0x89, 0xea, 0x8a, 0xa4,
	0x86, 0x4f, 0xdd, 0xcd, 0x2b, 0x38, 0x24, 0x46, 0x7d, 0xd8, 0xb0, 0x22, 0x41, 0xb4, 0x63, 0xbb,
	0xd7, 0xc0, 0x9d, 0xee, 0x47, 0xb3, 0x85, 0x48, 0x8c, 0x0e, 0x14, 0x54, 0x2e, 0x66, 0xdb, 0xb6,
	0x4d, 0x51, 0x96, 0xb9, 0xeb, 0x15, 0xb1, 0x49, 0x8c, 0xba, 0xb0, 0xa2, 0x63, 0x2c, 0xb4, 0xa5,
	0x82, 0x31, 0x13, 0xd0, 0xb9, 0xdb, 0x05, 0x5c, 0x6e, 0x4e, 0x47, 0x50, 0x9a, 0xb9, 0x1c, 0x12,
	0xd3, 0xcc, 0x59, 0xa0, 0x97, 0x4c, 0x0b, 0xf5, 0xd8, 0x92, 0x16, 0x81, 0xb1, 0x2c, 0x69, 0x91,
	0x38, 0x8a, 0xd7, 0x47, 0x36, 0x6d, 0xcd, 0xfa, 0x50, 0x46, 0xb6, 0x59, 0x1f, 0xda, 0x80, 0xfe,
	0x91, 0x01, 0x69, 0x13, 0x97, 0xa0, 0x0f, 0xf3, 0x2a, 0x06, 0xde, 0x71, 0xfd, 0x59, 0x22, 0x24,
	0x46, 0xcf, 0x60, 0x59, 0x43, 0x15, 0xe8, 0x03, 0x9b, 0x2b, 0x02, 0x9f, 0xb8, 0x5b, 0x57, 0x33,
	0xd5, 0x84, 0xca, 0x90, 0xf3, 0x09, 0x55, 0xa3, 0xde, 0x2e, 0xe0, 0x72, 0xd7, 0xb4, 0x65, 0xad,
	0xb9, 0x66, 0x42, 0x01, 0xcd, 0xb5, 0xfc, 0x8e, 0x3f, 0x84, 0x55, 0x73, 0xdd, 0x22, 0xb5, 0x3e,
	0x2d, 0x2b, 0xdd, 0xbd, 0x5f, 0xc8, 0x57, 0x2b, 0xce, 0x1a, 0x6f, 0x6e, 0x31, 0x5b, 0x2a, 0xce,
	0x8c, 0x57, 0xdb, 0x8c, 0x5a, 0xbc, 0xe6, 0xd6, 0xd5, 0xe2, 0xcd, 0x2f, 0xd4, 0x2e, 0x03, 0xe5,
	0xca, 0xb0, 0x43, 0x46, 0xea, 0xf4, 0xe9, 0xe9, 0x6e, 0x17, 0x70, 0x49, 0x8c, 0x7e, 0x82, 0x75,
	0xdb, 0x66, 0x42, 0x7e, 0x5e, 0xcd, 0xdc, 0x76, 0xee, 0xce, 0x4c, 0x19, 0x12, 0xa3, 0xef, 0x32,
	0xc8, 0xa9, 0xba, 0x7c, 0x3f, 0x57, 0x1f, 0x86, 0xd7, 0x8d, 0x62, 0x01, 0x6e, 0x37, 0x37, 0xf7,
	0x35, 0xbb, 0xb6, 0x5d, 0xa2, 0xd9, 0xb5, 0xae, 0x8d, 0xf6, 0xf7, 0xaf, 0x2f, 0x3c, 0xe7, 0xbf,
	0x0b, 0xcf, 0xf9, 0xff, 0xc2, 0x73, 0xfe, 0x9c, 0x78, 0xce, 0x5f, 0x13, 0xcf, 0xf9, 0x7b, 0xe2,
	0x2d, 0xfd, 0x33, 0xf1, 0x9c, 0x57, 0x13, 0xcf, 0x79, 0x3d, 0xf1, 0x9c, 0x3f, 0x2e, 0xbd, 0xa5,
	0x57, 0x97, 0xde, 0xd2, 0xbf, 0x97, 0xde, 0xd2, 0x0f, 0x0f, 0xe6, 0xfa, 0xe7, 0xa4, 0x7f, 0x83,
	0xfd, 0x5b, 0xf2, 0xe9, 0x9b, 0x00, 0x00, 0x00, 0xff, 0xff, 0x73, 0x5f, 0xa2, 0xe4, 0xde, 0x11,
	0x00, 0x00,
}

func (this *GetUserByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetUserByIDReq)
	if !ok {
		that2, ok := that.(GetUserByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetUserByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetUserByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetUserByIDReq but is not nil && this == nil")
	}
	if this.UserID != that1.UserID {
		return fmt.Errorf("UserID this(%v) Not Equal that(%v)", this.UserID, that1.UserID)
	}
	return nil
}
func (this *GetUserByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserByIDReq)
	if !ok {
		that2, ok := that.(GetUserByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserID != that1.UserID {
		return false
	}
	return true
}
func (this *GetUserByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetUserByIDResp)
	if !ok {
		that2, ok := that.(GetUserByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetUserByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetUserByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetUserByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if !this.User.Equal(that1.User) {
		return fmt.Errorf("User this(%v) Not Equal that(%v)", this.User, that1.User)
	}
	return nil
}
func (this *GetUserByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserByIDResp)
	if !ok {
		that2, ok := that.(GetUserByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if !this.User.Equal(that1.User) {
		return false
	}
	return true
}
func (this *CreateUserReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CreateUserReq)
	if !ok {
		that2, ok := that.(CreateUserReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CreateUserReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CreateUserReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CreateUserReq but is not nil && this == nil")
	}
	if !this.User.Equal(that1.User) {
		return fmt.Errorf("User this(%v) Not Equal that(%v)", this.User, that1.User)
	}
	return nil
}
func (this *CreateUserReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateUserReq)
	if !ok {
		that2, ok := that.(CreateUserReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.User.Equal(that1.User) {
		return false
	}
	return true
}
func (this *CreateUserResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CreateUserResp)
	if !ok {
		that2, ok := that.(CreateUserResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CreateUserResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CreateUserResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CreateUserResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *CreateUserResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateUserResp)
	if !ok {
		that2, ok := that.(CreateUserResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *GetUserByUsernamePassReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetUserByUsernamePassReq)
	if !ok {
		that2, ok := that.(GetUserByUsernamePassReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetUserByUsernamePassReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetUserByUsernamePassReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetUserByUsernamePassReq but is not nil && this == nil")
	}
	if this.Username != that1.Username {
		return fmt.Errorf("Username this(%v) Not Equal that(%v)", this.Username, that1.Username)
	}
	if this.Pass != that1.Pass {
		return fmt.Errorf("Pass this(%v) Not Equal that(%v)", this.Pass, that1.Pass)
	}
	return nil
}
func (this *GetUserByUsernamePassReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserByUsernamePassReq)
	if !ok {
		that2, ok := that.(GetUserByUsernamePassReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if this.Pass != that1.Pass {
		return false
	}
	return true
}
func (this *GetUserByUsernamePassResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetUserByUsernamePassResp)
	if !ok {
		that2, ok := that.(GetUserByUsernamePassResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetUserByUsernamePassResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetUserByUsernamePassResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetUserByUsernamePassResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if !this.User.Equal(that1.User) {
		return fmt.Errorf("User this(%v) Not Equal that(%v)", this.User, that1.User)
	}
	return nil
}
func (this *GetUserByUsernamePassResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserByUsernamePassResp)
	if !ok {
		that2, ok := that.(GetUserByUsernamePassResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if !this.User.Equal(that1.User) {
		return false
	}
	return true
}
func (this *GetUserByTeamIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetUserByTeamIDReq)
	if !ok {
		that2, ok := that.(GetUserByTeamIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetUserByTeamIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetUserByTeamIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetUserByTeamIDReq but is not nil && this == nil")
	}
	if this.TeamID != that1.TeamID {
		return fmt.Errorf("TeamID this(%v) Not Equal that(%v)", this.TeamID, that1.TeamID)
	}
	return nil
}
func (this *GetUserByTeamIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserByTeamIDReq)
	if !ok {
		that2, ok := that.(GetUserByTeamIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TeamID != that1.TeamID {
		return false
	}
	return true
}
func (this *GetUserByTeamIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetUserByTeamIDResp)
	if !ok {
		that2, ok := that.(GetUserByTeamIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetUserByTeamIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetUserByTeamIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetUserByTeamIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if len(this.Users) != len(that1.Users) {
		return fmt.Errorf("Users this(%v) Not Equal that(%v)", len(this.Users), len(that1.Users))
	}
	for i := range this.Users {
		if !this.Users[i].Equal(that1.Users[i]) {
			return fmt.Errorf("Users this[%v](%v) Not Equal that[%v](%v)", i, this.Users[i], i, that1.Users[i])
		}
	}
	return nil
}
func (this *GetUserByTeamIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserByTeamIDResp)
	if !ok {
		that2, ok := that.(GetUserByTeamIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if len(this.Users) != len(that1.Users) {
		return false
	}
	for i := range this.Users {
		if !this.Users[i].Equal(that1.Users[i]) {
			return false
		}
	}
	return true
}
func (this *UpdateUserByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateUserByIDReq)
	if !ok {
		that2, ok := that.(UpdateUserByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UpdateUserByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateUserByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateUserByIDReq but is not nil && this == nil")
	}
	if this.UserID != that1.UserID {
		return fmt.Errorf("UserID this(%v) Not Equal that(%v)", this.UserID, that1.UserID)
	}
	if !this.User.Equal(that1.User) {
		return fmt.Errorf("User this(%v) Not Equal that(%v)", this.User, that1.User)
	}
	return nil
}
func (this *UpdateUserByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateUserByIDReq)
	if !ok {
		that2, ok := that.(UpdateUserByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserID != that1.UserID {
		return false
	}
	if !this.User.Equal(that1.User) {
		return false
	}
	return true
}
func (this *UpdateUserByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateUserByIDResp)
	if !ok {
		that2, ok := that.(UpdateUserByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UpdateUserByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateUserByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateUserByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *UpdateUserByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateUserByIDResp)
	if !ok {
		that2, ok := that.(UpdateUserByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *DeleteUserByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeleteUserByIDReq)
	if !ok {
		that2, ok := that.(DeleteUserByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeleteUserByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeleteUserByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeleteUserByIDReq but is not nil && this == nil")
	}
	if this.UserID != that1.UserID {
		return fmt.Errorf("UserID this(%v) Not Equal that(%v)", this.UserID, that1.UserID)
	}
	return nil
}
func (this *DeleteUserByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteUserByIDReq)
	if !ok {
		that2, ok := that.(DeleteUserByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserID != that1.UserID {
		return false
	}
	return true
}
func (this *DeleteUserByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeleteUserByIDResp)
	if !ok {
		that2, ok := that.(DeleteUserByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeleteUserByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeleteUserByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeleteUserByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *DeleteUserByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteUserByIDResp)
	if !ok {
		that2, ok := that.(DeleteUserByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *CreateTeamReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CreateTeamReq)
	if !ok {
		that2, ok := that.(CreateTeamReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CreateTeamReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CreateTeamReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CreateTeamReq but is not nil && this == nil")
	}
	if !this.Team.Equal(that1.Team) {
		return fmt.Errorf("Team this(%v) Not Equal that(%v)", this.Team, that1.Team)
	}
	return nil
}
func (this *CreateTeamReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateTeamReq)
	if !ok {
		that2, ok := that.(CreateTeamReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Team.Equal(that1.Team) {
		return false
	}
	return true
}
func (this *CreateTeamResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CreateTeamResp)
	if !ok {
		that2, ok := that.(CreateTeamResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CreateTeamResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CreateTeamResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CreateTeamResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *CreateTeamResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateTeamResp)
	if !ok {
		that2, ok := that.(CreateTeamResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *GetTeamByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetTeamByIDReq)
	if !ok {
		that2, ok := that.(GetTeamByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetTeamByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetTeamByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetTeamByIDReq but is not nil && this == nil")
	}
	if this.TeamID != that1.TeamID {
		return fmt.Errorf("TeamID this(%v) Not Equal that(%v)", this.TeamID, that1.TeamID)
	}
	return nil
}
func (this *GetTeamByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTeamByIDReq)
	if !ok {
		that2, ok := that.(GetTeamByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TeamID != that1.TeamID {
		return false
	}
	return true
}
func (this *GetTeamByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetTeamByIDResp)
	if !ok {
		that2, ok := that.(GetTeamByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetTeamByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetTeamByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetTeamByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if !this.Team.Equal(that1.Team) {
		return fmt.Errorf("Team this(%v) Not Equal that(%v)", this.Team, that1.Team)
	}
	return nil
}
func (this *GetTeamByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTeamByIDResp)
	if !ok {
		that2, ok := that.(GetTeamByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if !this.Team.Equal(that1.Team) {
		return false
	}
	return true
}
func (this *GetTeamsByCreatorIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetTeamsByCreatorIDReq)
	if !ok {
		that2, ok := that.(GetTeamsByCreatorIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetTeamsByCreatorIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetTeamsByCreatorIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetTeamsByCreatorIDReq but is not nil && this == nil")
	}
	if this.CreatorID != that1.CreatorID {
		return fmt.Errorf("CreatorID this(%v) Not Equal that(%v)", this.CreatorID, that1.CreatorID)
	}
	return nil
}
func (this *GetTeamsByCreatorIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTeamsByCreatorIDReq)
	if !ok {
		that2, ok := that.(GetTeamsByCreatorIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CreatorID != that1.CreatorID {
		return false
	}
	return true
}
func (this *GetTeamsByCreatorIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetTeamsByCreatorIDResp)
	if !ok {
		that2, ok := that.(GetTeamsByCreatorIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetTeamsByCreatorIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetTeamsByCreatorIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetTeamsByCreatorIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if len(this.Teams) != len(that1.Teams) {
		return fmt.Errorf("Teams this(%v) Not Equal that(%v)", len(this.Teams), len(that1.Teams))
	}
	for i := range this.Teams {
		if !this.Teams[i].Equal(that1.Teams[i]) {
			return fmt.Errorf("Teams this[%v](%v) Not Equal that[%v](%v)", i, this.Teams[i], i, that1.Teams[i])
		}
	}
	return nil
}
func (this *GetTeamsByCreatorIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTeamsByCreatorIDResp)
	if !ok {
		that2, ok := that.(GetTeamsByCreatorIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if len(this.Teams) != len(that1.Teams) {
		return false
	}
	for i := range this.Teams {
		if !this.Teams[i].Equal(that1.Teams[i]) {
			return false
		}
	}
	return true
}
func (this *GetTeamByNameReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetTeamByNameReq)
	if !ok {
		that2, ok := that.(GetTeamByNameReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetTeamByNameReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetTeamByNameReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetTeamByNameReq but is not nil && this == nil")
	}
	if this.TeamName != that1.TeamName {
		return fmt.Errorf("TeamName this(%v) Not Equal that(%v)", this.TeamName, that1.TeamName)
	}
	return nil
}
func (this *GetTeamByNameReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTeamByNameReq)
	if !ok {
		that2, ok := that.(GetTeamByNameReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TeamName != that1.TeamName {
		return false
	}
	return true
}
func (this *GetTeamByNameResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetTeamByNameResp)
	if !ok {
		that2, ok := that.(GetTeamByNameResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetTeamByNameResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetTeamByNameResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetTeamByNameResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if len(this.Teams) != len(that1.Teams) {
		return fmt.Errorf("Teams this(%v) Not Equal that(%v)", len(this.Teams), len(that1.Teams))
	}
	for i := range this.Teams {
		if !this.Teams[i].Equal(that1.Teams[i]) {
			return fmt.Errorf("Teams this[%v](%v) Not Equal that[%v](%v)", i, this.Teams[i], i, that1.Teams[i])
		}
	}
	return nil
}
func (this *GetTeamByNameResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTeamByNameResp)
	if !ok {
		that2, ok := that.(GetTeamByNameResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if len(this.Teams) != len(that1.Teams) {
		return false
	}
	for i := range this.Teams {
		if !this.Teams[i].Equal(that1.Teams[i]) {
			return false
		}
	}
	return true
}
func (this *UpdateTeamByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateTeamByIDReq)
	if !ok {
		that2, ok := that.(UpdateTeamByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UpdateTeamByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateTeamByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateTeamByIDReq but is not nil && this == nil")
	}
	if this.TeamID != that1.TeamID {
		return fmt.Errorf("TeamID this(%v) Not Equal that(%v)", this.TeamID, that1.TeamID)
	}
	if !this.Team.Equal(that1.Team) {
		return fmt.Errorf("Team this(%v) Not Equal that(%v)", this.Team, that1.Team)
	}
	return nil
}
func (this *UpdateTeamByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateTeamByIDReq)
	if !ok {
		that2, ok := that.(UpdateTeamByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TeamID != that1.TeamID {
		return false
	}
	if !this.Team.Equal(that1.Team) {
		return false
	}
	return true
}
func (this *UpdateTeamByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateTeamByIDResp)
	if !ok {
		that2, ok := that.(UpdateTeamByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UpdateTeamByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateTeamByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateTeamByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *UpdateTeamByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateTeamByIDResp)
	if !ok {
		that2, ok := that.(UpdateTeamByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *AddMemberByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AddMemberByIDReq)
	if !ok {
		that2, ok := that.(AddMemberByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AddMemberByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AddMemberByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AddMemberByIDReq but is not nil && this == nil")
	}
	if this.TeamID != that1.TeamID {
		return fmt.Errorf("TeamID this(%v) Not Equal that(%v)", this.TeamID, that1.TeamID)
	}
	if this.UserID != that1.UserID {
		return fmt.Errorf("UserID this(%v) Not Equal that(%v)", this.UserID, that1.UserID)
	}
	return nil
}
func (this *AddMemberByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddMemberByIDReq)
	if !ok {
		that2, ok := that.(AddMemberByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TeamID != that1.TeamID {
		return false
	}
	if this.UserID != that1.UserID {
		return false
	}
	return true
}
func (this *AddMemberByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AddMemberByIDResp)
	if !ok {
		that2, ok := that.(AddMemberByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AddMemberByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AddMemberByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AddMemberByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *AddMemberByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddMemberByIDResp)
	if !ok {
		that2, ok := that.(AddMemberByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *RemoveMemberByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RemoveMemberByIDReq)
	if !ok {
		that2, ok := that.(RemoveMemberByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RemoveMemberByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RemoveMemberByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RemoveMemberByIDReq but is not nil && this == nil")
	}
	if this.TeamID != that1.TeamID {
		return fmt.Errorf("TeamID this(%v) Not Equal that(%v)", this.TeamID, that1.TeamID)
	}
	if this.UserID != that1.UserID {
		return fmt.Errorf("UserID this(%v) Not Equal that(%v)", this.UserID, that1.UserID)
	}
	return nil
}
func (this *RemoveMemberByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoveMemberByIDReq)
	if !ok {
		that2, ok := that.(RemoveMemberByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TeamID != that1.TeamID {
		return false
	}
	if this.UserID != that1.UserID {
		return false
	}
	return true
}
func (this *RemoveMemberByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RemoveMemberByIDResp)
	if !ok {
		that2, ok := that.(RemoveMemberByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RemoveMemberByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RemoveMemberByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RemoveMemberByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *RemoveMemberByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoveMemberByIDResp)
	if !ok {
		that2, ok := that.(RemoveMemberByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *DeleteTeamByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeleteTeamByIDReq)
	if !ok {
		that2, ok := that.(DeleteTeamByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeleteTeamByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeleteTeamByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeleteTeamByIDReq but is not nil && this == nil")
	}
	if this.TeamID != that1.TeamID {
		return fmt.Errorf("TeamID this(%v) Not Equal that(%v)", this.TeamID, that1.TeamID)
	}
	return nil
}
func (this *DeleteTeamByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteTeamByIDReq)
	if !ok {
		that2, ok := that.(DeleteTeamByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TeamID != that1.TeamID {
		return false
	}
	return true
}
func (this *DeleteTeamByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeleteTeamByIDResp)
	if !ok {
		that2, ok := that.(DeleteTeamByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeleteTeamByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeleteTeamByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeleteTeamByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *DeleteTeamByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteTeamByIDResp)
	if !ok {
		that2, ok := that.(DeleteTeamByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *CreateProjectReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CreateProjectReq)
	if !ok {
		that2, ok := that.(CreateProjectReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CreateProjectReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CreateProjectReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CreateProjectReq but is not nil && this == nil")
	}
	if !this.Project.Equal(that1.Project) {
		return fmt.Errorf("Project this(%v) Not Equal that(%v)", this.Project, that1.Project)
	}
	return nil
}
func (this *CreateProjectReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateProjectReq)
	if !ok {
		that2, ok := that.(CreateProjectReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Project.Equal(that1.Project) {
		return false
	}
	return true
}
func (this *CreateProjectResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CreateProjectResp)
	if !ok {
		that2, ok := that.(CreateProjectResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CreateProjectResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CreateProjectResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CreateProjectResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *CreateProjectResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateProjectResp)
	if !ok {
		that2, ok := that.(CreateProjectResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *GetProjectByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetProjectByIDReq)
	if !ok {
		that2, ok := that.(GetProjectByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetProjectByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetProjectByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetProjectByIDReq but is not nil && this == nil")
	}
	if this.ProjectID != that1.ProjectID {
		return fmt.Errorf("ProjectID this(%v) Not Equal that(%v)", this.ProjectID, that1.ProjectID)
	}
	return nil
}
func (this *GetProjectByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetProjectByIDReq)
	if !ok {
		that2, ok := that.(GetProjectByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProjectID != that1.ProjectID {
		return false
	}
	return true
}
func (this *GetProjectByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetProjectByIDResp)
	if !ok {
		that2, ok := that.(GetProjectByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetProjectByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetProjectByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetProjectByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if !this.Project.Equal(that1.Project) {
		return fmt.Errorf("Project this(%v) Not Equal that(%v)", this.Project, that1.Project)
	}
	return nil
}
func (this *GetProjectByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetProjectByIDResp)
	if !ok {
		that2, ok := that.(GetProjectByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if !this.Project.Equal(that1.Project) {
		return false
	}
	return true
}
func (this *GetProjtectsByTeamIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetProjtectsByTeamIDReq)
	if !ok {
		that2, ok := that.(GetProjtectsByTeamIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetProjtectsByTeamIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetProjtectsByTeamIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetProjtectsByTeamIDReq but is not nil && this == nil")
	}
	if this.TeamID != that1.TeamID {
		return fmt.Errorf("TeamID this(%v) Not Equal that(%v)", this.TeamID, that1.TeamID)
	}
	return nil
}
func (this *GetProjtectsByTeamIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetProjtectsByTeamIDReq)
	if !ok {
		that2, ok := that.(GetProjtectsByTeamIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TeamID != that1.TeamID {
		return false
	}
	return true
}
func (this *GetProjtectsByTeamIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetProjtectsByTeamIDResp)
	if !ok {
		that2, ok := that.(GetProjtectsByTeamIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetProjtectsByTeamIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetProjtectsByTeamIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetProjtectsByTeamIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if len(this.Projects) != len(that1.Projects) {
		return fmt.Errorf("Projects this(%v) Not Equal that(%v)", len(this.Projects), len(that1.Projects))
	}
	for i := range this.Projects {
		if !this.Projects[i].Equal(that1.Projects[i]) {
			return fmt.Errorf("Projects this[%v](%v) Not Equal that[%v](%v)", i, this.Projects[i], i, that1.Projects[i])
		}
	}
	return nil
}
func (this *GetProjtectsByTeamIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetProjtectsByTeamIDResp)
	if !ok {
		that2, ok := that.(GetProjtectsByTeamIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if len(this.Projects) != len(that1.Projects) {
		return false
	}
	for i := range this.Projects {
		if !this.Projects[i].Equal(that1.Projects[i]) {
			return false
		}
	}
	return true
}
func (this *UpdateProjectByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateProjectByIDReq)
	if !ok {
		that2, ok := that.(UpdateProjectByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UpdateProjectByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateProjectByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateProjectByIDReq but is not nil && this == nil")
	}
	if this.ProjectID != that1.ProjectID {
		return fmt.Errorf("ProjectID this(%v) Not Equal that(%v)", this.ProjectID, that1.ProjectID)
	}
	if !this.Project.Equal(that1.Project) {
		return fmt.Errorf("Project this(%v) Not Equal that(%v)", this.Project, that1.Project)
	}
	return nil
}
func (this *UpdateProjectByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateProjectByIDReq)
	if !ok {
		that2, ok := that.(UpdateProjectByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProjectID != that1.ProjectID {
		return false
	}
	if !this.Project.Equal(that1.Project) {
		return false
	}
	return true
}
func (this *UpdateProjectByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateProjectByIDResp)
	if !ok {
		that2, ok := that.(UpdateProjectByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UpdateProjectByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateProjectByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateProjectByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *UpdateProjectByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateProjectByIDResp)
	if !ok {
		that2, ok := that.(UpdateProjectByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *DeleteProjectByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeleteProjectByIDReq)
	if !ok {
		that2, ok := that.(DeleteProjectByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeleteProjectByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeleteProjectByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeleteProjectByIDReq but is not nil && this == nil")
	}
	if this.ProjectID != that1.ProjectID {
		return fmt.Errorf("ProjectID this(%v) Not Equal that(%v)", this.ProjectID, that1.ProjectID)
	}
	return nil
}
func (this *DeleteProjectByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteProjectByIDReq)
	if !ok {
		that2, ok := that.(DeleteProjectByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProjectID != that1.ProjectID {
		return false
	}
	return true
}
func (this *DeleteProjectByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeleteProjectByIDResp)
	if !ok {
		that2, ok := that.(DeleteProjectByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeleteProjectByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeleteProjectByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeleteProjectByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *DeleteProjectByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteProjectByIDResp)
	if !ok {
		that2, ok := that.(DeleteProjectByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *GetUserByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usrmanrpc.GetUserByIDReq{")
	s = append(s, "UserID: "+fmt.Sprintf("%#v", this.UserID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUserByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&usrmanrpc.GetUserByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.User != nil {
		s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateUserReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usrmanrpc.CreateUserReq{")
	if this.User != nil {
		s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateUserResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.CreateUserResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUserByUsernamePassReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.GetUserByUsernamePassReq{")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "Pass: "+fmt.Sprintf("%#v", this.Pass)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUserByUsernamePassResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&usrmanrpc.GetUserByUsernamePassResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.User != nil {
		s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUserByTeamIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usrmanrpc.GetUserByTeamIDReq{")
	s = append(s, "TeamID: "+fmt.Sprintf("%#v", this.TeamID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUserByTeamIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&usrmanrpc.GetUserByTeamIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Users != nil {
		s = append(s, "Users: "+fmt.Sprintf("%#v", this.Users)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateUserByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.UpdateUserByIDReq{")
	s = append(s, "UserID: "+fmt.Sprintf("%#v", this.UserID)+",\n")
	if this.User != nil {
		s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateUserByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.UpdateUserByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteUserByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usrmanrpc.DeleteUserByIDReq{")
	s = append(s, "UserID: "+fmt.Sprintf("%#v", this.UserID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteUserByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.DeleteUserByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateTeamReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usrmanrpc.CreateTeamReq{")
	if this.Team != nil {
		s = append(s, "Team: "+fmt.Sprintf("%#v", this.Team)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateTeamResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.CreateTeamResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTeamByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usrmanrpc.GetTeamByIDReq{")
	s = append(s, "TeamID: "+fmt.Sprintf("%#v", this.TeamID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTeamByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&usrmanrpc.GetTeamByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Team != nil {
		s = append(s, "Team: "+fmt.Sprintf("%#v", this.Team)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTeamsByCreatorIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usrmanrpc.GetTeamsByCreatorIDReq{")
	s = append(s, "CreatorID: "+fmt.Sprintf("%#v", this.CreatorID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTeamsByCreatorIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&usrmanrpc.GetTeamsByCreatorIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Teams != nil {
		s = append(s, "Teams: "+fmt.Sprintf("%#v", this.Teams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTeamByNameReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usrmanrpc.GetTeamByNameReq{")
	s = append(s, "TeamName: "+fmt.Sprintf("%#v", this.TeamName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTeamByNameResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&usrmanrpc.GetTeamByNameResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Teams != nil {
		s = append(s, "Teams: "+fmt.Sprintf("%#v", this.Teams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateTeamByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.UpdateTeamByIDReq{")
	s = append(s, "TeamID: "+fmt.Sprintf("%#v", this.TeamID)+",\n")
	if this.Team != nil {
		s = append(s, "Team: "+fmt.Sprintf("%#v", this.Team)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateTeamByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.UpdateTeamByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AddMemberByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.AddMemberByIDReq{")
	s = append(s, "TeamID: "+fmt.Sprintf("%#v", this.TeamID)+",\n")
	s = append(s, "UserID: "+fmt.Sprintf("%#v", this.UserID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AddMemberByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.AddMemberByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoveMemberByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.RemoveMemberByIDReq{")
	s = append(s, "TeamID: "+fmt.Sprintf("%#v", this.TeamID)+",\n")
	s = append(s, "UserID: "+fmt.Sprintf("%#v", this.UserID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoveMemberByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.RemoveMemberByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteTeamByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usrmanrpc.DeleteTeamByIDReq{")
	s = append(s, "TeamID: "+fmt.Sprintf("%#v", this.TeamID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteTeamByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.DeleteTeamByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateProjectReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usrmanrpc.CreateProjectReq{")
	if this.Project != nil {
		s = append(s, "Project: "+fmt.Sprintf("%#v", this.Project)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateProjectResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.CreateProjectResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetProjectByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usrmanrpc.GetProjectByIDReq{")
	s = append(s, "ProjectID: "+fmt.Sprintf("%#v", this.ProjectID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetProjectByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&usrmanrpc.GetProjectByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Project != nil {
		s = append(s, "Project: "+fmt.Sprintf("%#v", this.Project)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetProjtectsByTeamIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usrmanrpc.GetProjtectsByTeamIDReq{")
	s = append(s, "TeamID: "+fmt.Sprintf("%#v", this.TeamID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetProjtectsByTeamIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&usrmanrpc.GetProjtectsByTeamIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Projects != nil {
		s = append(s, "Projects: "+fmt.Sprintf("%#v", this.Projects)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateProjectByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.UpdateProjectByIDReq{")
	s = append(s, "ProjectID: "+fmt.Sprintf("%#v", this.ProjectID)+",\n")
	if this.Project != nil {
		s = append(s, "Project: "+fmt.Sprintf("%#v", this.Project)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateProjectByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.UpdateProjectByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteProjectByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usrmanrpc.DeleteProjectByIDReq{")
	s = append(s, "ProjectID: "+fmt.Sprintf("%#v", this.ProjectID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteProjectByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usrmanrpc.DeleteProjectByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringUsrmanService(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// UsrManSrvClient is the client API for UsrManSrv service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UsrManSrvClient interface {
	GetUserByID(ctx context.Context, in *GetUserByIDReq, opts ...grpc.CallOption) (*GetUserByIDResp, error)
	CreateUser(ctx context.Context, in *CreateUserReq, opts ...grpc.CallOption) (*CreateUserResp, error)
	GetUserByUsernamePass(ctx context.Context, in *GetUserByUsernamePassReq, opts ...grpc.CallOption) (*GetUserByUsernamePassResp, error)
	GetUserByTeamID(ctx context.Context, in *GetUserByTeamIDReq, opts ...grpc.CallOption) (*GetUserByTeamIDResp, error)
	UpdateUserByID(ctx context.Context, in *UpdateUserByIDReq, opts ...grpc.CallOption) (*UpdateUserByIDResp, error)
	DeleteUserByID(ctx context.Context, in *DeleteUserByIDReq, opts ...grpc.CallOption) (*DeleteUserByIDResp, error)
	CreateTeam(ctx context.Context, in *CreateTeamReq, opts ...grpc.CallOption) (*CreateTeamResp, error)
	GetTeamByID(ctx context.Context, in *GetTeamByIDReq, opts ...grpc.CallOption) (*GetTeamByIDResp, error)
	GetTeamsByCreatorID(ctx context.Context, in *GetTeamsByCreatorIDReq, opts ...grpc.CallOption) (*GetTeamsByCreatorIDResp, error)
	GetTeamByName(ctx context.Context, in *GetTeamByNameReq, opts ...grpc.CallOption) (*GetTeamByNameResp, error)
	UpdateTeamByID(ctx context.Context, in *UpdateTeamByIDReq, opts ...grpc.CallOption) (*UpdateTeamByIDResp, error)
	AddMemberByID(ctx context.Context, in *AddMemberByIDReq, opts ...grpc.CallOption) (*AddMemberByIDResp, error)
	RemoveMemberByID(ctx context.Context, in *RemoveMemberByIDReq, opts ...grpc.CallOption) (*RemoveMemberByIDResp, error)
	DeleteTeamByID(ctx context.Context, in *DeleteTeamByIDReq, opts ...grpc.CallOption) (*DeleteTeamByIDResp, error)
	CreateProject(ctx context.Context, in *CreateProjectReq, opts ...grpc.CallOption) (*CreateProjectResp, error)
	GetProjectByID(ctx context.Context, in *GetProjectByIDReq, opts ...grpc.CallOption) (*GetProjectByIDResp, error)
	GetProjtectsByTeamID(ctx context.Context, in *GetProjtectsByTeamIDReq, opts ...grpc.CallOption) (*GetProjtectsByTeamIDResp, error)
	UpdateProjectByID(ctx context.Context, in *UpdateProjectByIDReq, opts ...grpc.CallOption) (*UpdateProjectByIDResp, error)
	DeleteProjectByID(ctx context.Context, in *DeleteProjectByIDReq, opts ...grpc.CallOption) (*DeleteProjectByIDResp, error)
}

type usrManSrvClient struct {
	cc *grpc.ClientConn
}

func NewUsrManSrvClient(cc *grpc.ClientConn) UsrManSrvClient {
	return &usrManSrvClient{cc}
}

func (c *usrManSrvClient) GetUserByID(ctx context.Context, in *GetUserByIDReq, opts ...grpc.CallOption) (*GetUserByIDResp, error) {
	out := new(GetUserByIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/GetUserByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) CreateUser(ctx context.Context, in *CreateUserReq, opts ...grpc.CallOption) (*CreateUserResp, error) {
	out := new(CreateUserResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) GetUserByUsernamePass(ctx context.Context, in *GetUserByUsernamePassReq, opts ...grpc.CallOption) (*GetUserByUsernamePassResp, error) {
	out := new(GetUserByUsernamePassResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/GetUserByUsernamePass", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) GetUserByTeamID(ctx context.Context, in *GetUserByTeamIDReq, opts ...grpc.CallOption) (*GetUserByTeamIDResp, error) {
	out := new(GetUserByTeamIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/GetUserByTeamID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) UpdateUserByID(ctx context.Context, in *UpdateUserByIDReq, opts ...grpc.CallOption) (*UpdateUserByIDResp, error) {
	out := new(UpdateUserByIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/UpdateUserByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) DeleteUserByID(ctx context.Context, in *DeleteUserByIDReq, opts ...grpc.CallOption) (*DeleteUserByIDResp, error) {
	out := new(DeleteUserByIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/DeleteUserByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) CreateTeam(ctx context.Context, in *CreateTeamReq, opts ...grpc.CallOption) (*CreateTeamResp, error) {
	out := new(CreateTeamResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/CreateTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) GetTeamByID(ctx context.Context, in *GetTeamByIDReq, opts ...grpc.CallOption) (*GetTeamByIDResp, error) {
	out := new(GetTeamByIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/GetTeamByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) GetTeamsByCreatorID(ctx context.Context, in *GetTeamsByCreatorIDReq, opts ...grpc.CallOption) (*GetTeamsByCreatorIDResp, error) {
	out := new(GetTeamsByCreatorIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/GetTeamsByCreatorID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) GetTeamByName(ctx context.Context, in *GetTeamByNameReq, opts ...grpc.CallOption) (*GetTeamByNameResp, error) {
	out := new(GetTeamByNameResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/GetTeamByName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) UpdateTeamByID(ctx context.Context, in *UpdateTeamByIDReq, opts ...grpc.CallOption) (*UpdateTeamByIDResp, error) {
	out := new(UpdateTeamByIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/UpdateTeamByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) AddMemberByID(ctx context.Context, in *AddMemberByIDReq, opts ...grpc.CallOption) (*AddMemberByIDResp, error) {
	out := new(AddMemberByIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/AddMemberByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) RemoveMemberByID(ctx context.Context, in *RemoveMemberByIDReq, opts ...grpc.CallOption) (*RemoveMemberByIDResp, error) {
	out := new(RemoveMemberByIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/RemoveMemberByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) DeleteTeamByID(ctx context.Context, in *DeleteTeamByIDReq, opts ...grpc.CallOption) (*DeleteTeamByIDResp, error) {
	out := new(DeleteTeamByIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/DeleteTeamByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) CreateProject(ctx context.Context, in *CreateProjectReq, opts ...grpc.CallOption) (*CreateProjectResp, error) {
	out := new(CreateProjectResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/CreateProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) GetProjectByID(ctx context.Context, in *GetProjectByIDReq, opts ...grpc.CallOption) (*GetProjectByIDResp, error) {
	out := new(GetProjectByIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/GetProjectByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) GetProjtectsByTeamID(ctx context.Context, in *GetProjtectsByTeamIDReq, opts ...grpc.CallOption) (*GetProjtectsByTeamIDResp, error) {
	out := new(GetProjtectsByTeamIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/GetProjtectsByTeamID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) UpdateProjectByID(ctx context.Context, in *UpdateProjectByIDReq, opts ...grpc.CallOption) (*UpdateProjectByIDResp, error) {
	out := new(UpdateProjectByIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/UpdateProjectByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usrManSrvClient) DeleteProjectByID(ctx context.Context, in *DeleteProjectByIDReq, opts ...grpc.CallOption) (*DeleteProjectByIDResp, error) {
	out := new(DeleteProjectByIDResp)
	err := c.cc.Invoke(ctx, "/usrmanrpc.UsrManSrv/DeleteProjectByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UsrManSrvServer is the server API for UsrManSrv service.
type UsrManSrvServer interface {
	GetUserByID(context.Context, *GetUserByIDReq) (*GetUserByIDResp, error)
	CreateUser(context.Context, *CreateUserReq) (*CreateUserResp, error)
	GetUserByUsernamePass(context.Context, *GetUserByUsernamePassReq) (*GetUserByUsernamePassResp, error)
	GetUserByTeamID(context.Context, *GetUserByTeamIDReq) (*GetUserByTeamIDResp, error)
	UpdateUserByID(context.Context, *UpdateUserByIDReq) (*UpdateUserByIDResp, error)
	DeleteUserByID(context.Context, *DeleteUserByIDReq) (*DeleteUserByIDResp, error)
	CreateTeam(context.Context, *CreateTeamReq) (*CreateTeamResp, error)
	GetTeamByID(context.Context, *GetTeamByIDReq) (*GetTeamByIDResp, error)
	GetTeamsByCreatorID(context.Context, *GetTeamsByCreatorIDReq) (*GetTeamsByCreatorIDResp, error)
	GetTeamByName(context.Context, *GetTeamByNameReq) (*GetTeamByNameResp, error)
	UpdateTeamByID(context.Context, *UpdateTeamByIDReq) (*UpdateTeamByIDResp, error)
	AddMemberByID(context.Context, *AddMemberByIDReq) (*AddMemberByIDResp, error)
	RemoveMemberByID(context.Context, *RemoveMemberByIDReq) (*RemoveMemberByIDResp, error)
	DeleteTeamByID(context.Context, *DeleteTeamByIDReq) (*DeleteTeamByIDResp, error)
	CreateProject(context.Context, *CreateProjectReq) (*CreateProjectResp, error)
	GetProjectByID(context.Context, *GetProjectByIDReq) (*GetProjectByIDResp, error)
	GetProjtectsByTeamID(context.Context, *GetProjtectsByTeamIDReq) (*GetProjtectsByTeamIDResp, error)
	UpdateProjectByID(context.Context, *UpdateProjectByIDReq) (*UpdateProjectByIDResp, error)
	DeleteProjectByID(context.Context, *DeleteProjectByIDReq) (*DeleteProjectByIDResp, error)
}

// UnimplementedUsrManSrvServer can be embedded to have forward compatible implementations.
type UnimplementedUsrManSrvServer struct {
}

func (*UnimplementedUsrManSrvServer) GetUserByID(ctx context.Context, req *GetUserByIDReq) (*GetUserByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserByID not implemented")
}
func (*UnimplementedUsrManSrvServer) CreateUser(ctx context.Context, req *CreateUserReq) (*CreateUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (*UnimplementedUsrManSrvServer) GetUserByUsernamePass(ctx context.Context, req *GetUserByUsernamePassReq) (*GetUserByUsernamePassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserByUsernamePass not implemented")
}
func (*UnimplementedUsrManSrvServer) GetUserByTeamID(ctx context.Context, req *GetUserByTeamIDReq) (*GetUserByTeamIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserByTeamID not implemented")
}
func (*UnimplementedUsrManSrvServer) UpdateUserByID(ctx context.Context, req *UpdateUserByIDReq) (*UpdateUserByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserByID not implemented")
}
func (*UnimplementedUsrManSrvServer) DeleteUserByID(ctx context.Context, req *DeleteUserByIDReq) (*DeleteUserByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserByID not implemented")
}
func (*UnimplementedUsrManSrvServer) CreateTeam(ctx context.Context, req *CreateTeamReq) (*CreateTeamResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTeam not implemented")
}
func (*UnimplementedUsrManSrvServer) GetTeamByID(ctx context.Context, req *GetTeamByIDReq) (*GetTeamByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTeamByID not implemented")
}
func (*UnimplementedUsrManSrvServer) GetTeamsByCreatorID(ctx context.Context, req *GetTeamsByCreatorIDReq) (*GetTeamsByCreatorIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTeamsByCreatorID not implemented")
}
func (*UnimplementedUsrManSrvServer) GetTeamByName(ctx context.Context, req *GetTeamByNameReq) (*GetTeamByNameResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTeamByName not implemented")
}
func (*UnimplementedUsrManSrvServer) UpdateTeamByID(ctx context.Context, req *UpdateTeamByIDReq) (*UpdateTeamByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTeamByID not implemented")
}
func (*UnimplementedUsrManSrvServer) AddMemberByID(ctx context.Context, req *AddMemberByIDReq) (*AddMemberByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMemberByID not implemented")
}
func (*UnimplementedUsrManSrvServer) RemoveMemberByID(ctx context.Context, req *RemoveMemberByIDReq) (*RemoveMemberByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveMemberByID not implemented")
}
func (*UnimplementedUsrManSrvServer) DeleteTeamByID(ctx context.Context, req *DeleteTeamByIDReq) (*DeleteTeamByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTeamByID not implemented")
}
func (*UnimplementedUsrManSrvServer) CreateProject(ctx context.Context, req *CreateProjectReq) (*CreateProjectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProject not implemented")
}
func (*UnimplementedUsrManSrvServer) GetProjectByID(ctx context.Context, req *GetProjectByIDReq) (*GetProjectByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectByID not implemented")
}
func (*UnimplementedUsrManSrvServer) GetProjtectsByTeamID(ctx context.Context, req *GetProjtectsByTeamIDReq) (*GetProjtectsByTeamIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjtectsByTeamID not implemented")
}
func (*UnimplementedUsrManSrvServer) UpdateProjectByID(ctx context.Context, req *UpdateProjectByIDReq) (*UpdateProjectByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProjectByID not implemented")
}
func (*UnimplementedUsrManSrvServer) DeleteProjectByID(ctx context.Context, req *DeleteProjectByIDReq) (*DeleteProjectByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProjectByID not implemented")
}

func RegisterUsrManSrvServer(s *grpc.Server, srv UsrManSrvServer) {
	s.RegisterService(&_UsrManSrv_serviceDesc, srv)
}

func _UsrManSrv_GetUserByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).GetUserByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/GetUserByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).GetUserByID(ctx, req.(*GetUserByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).CreateUser(ctx, req.(*CreateUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_GetUserByUsernamePass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserByUsernamePassReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).GetUserByUsernamePass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/GetUserByUsernamePass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).GetUserByUsernamePass(ctx, req.(*GetUserByUsernamePassReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_GetUserByTeamID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserByTeamIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).GetUserByTeamID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/GetUserByTeamID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).GetUserByTeamID(ctx, req.(*GetUserByTeamIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_UpdateUserByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).UpdateUserByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/UpdateUserByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).UpdateUserByID(ctx, req.(*UpdateUserByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_DeleteUserByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).DeleteUserByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/DeleteUserByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).DeleteUserByID(ctx, req.(*DeleteUserByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_CreateTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).CreateTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/CreateTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).CreateTeam(ctx, req.(*CreateTeamReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_GetTeamByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).GetTeamByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/GetTeamByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).GetTeamByID(ctx, req.(*GetTeamByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_GetTeamsByCreatorID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamsByCreatorIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).GetTeamsByCreatorID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/GetTeamsByCreatorID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).GetTeamsByCreatorID(ctx, req.(*GetTeamsByCreatorIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_GetTeamByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamByNameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).GetTeamByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/GetTeamByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).GetTeamByName(ctx, req.(*GetTeamByNameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_UpdateTeamByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).UpdateTeamByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/UpdateTeamByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).UpdateTeamByID(ctx, req.(*UpdateTeamByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_AddMemberByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMemberByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).AddMemberByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/AddMemberByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).AddMemberByID(ctx, req.(*AddMemberByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_RemoveMemberByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveMemberByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).RemoveMemberByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/RemoveMemberByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).RemoveMemberByID(ctx, req.(*RemoveMemberByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_DeleteTeamByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTeamByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).DeleteTeamByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/DeleteTeamByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).DeleteTeamByID(ctx, req.(*DeleteTeamByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_CreateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProjectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).CreateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/CreateProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).CreateProject(ctx, req.(*CreateProjectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_GetProjectByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).GetProjectByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/GetProjectByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).GetProjectByID(ctx, req.(*GetProjectByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_GetProjtectsByTeamID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjtectsByTeamIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).GetProjtectsByTeamID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/GetProjtectsByTeamID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).GetProjtectsByTeamID(ctx, req.(*GetProjtectsByTeamIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_UpdateProjectByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProjectByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).UpdateProjectByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/UpdateProjectByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).UpdateProjectByID(ctx, req.(*UpdateProjectByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsrManSrv_DeleteProjectByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProjectByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsrManSrvServer).DeleteProjectByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usrmanrpc.UsrManSrv/DeleteProjectByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsrManSrvServer).DeleteProjectByID(ctx, req.(*DeleteProjectByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _UsrManSrv_serviceDesc = grpc.ServiceDesc{
	ServiceName: "usrmanrpc.UsrManSrv",
	HandlerType: (*UsrManSrvServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserByID",
			Handler:    _UsrManSrv_GetUserByID_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _UsrManSrv_CreateUser_Handler,
		},
		{
			MethodName: "GetUserByUsernamePass",
			Handler:    _UsrManSrv_GetUserByUsernamePass_Handler,
		},
		{
			MethodName: "GetUserByTeamID",
			Handler:    _UsrManSrv_GetUserByTeamID_Handler,
		},
		{
			MethodName: "UpdateUserByID",
			Handler:    _UsrManSrv_UpdateUserByID_Handler,
		},
		{
			MethodName: "DeleteUserByID",
			Handler:    _UsrManSrv_DeleteUserByID_Handler,
		},
		{
			MethodName: "CreateTeam",
			Handler:    _UsrManSrv_CreateTeam_Handler,
		},
		{
			MethodName: "GetTeamByID",
			Handler:    _UsrManSrv_GetTeamByID_Handler,
		},
		{
			MethodName: "GetTeamsByCreatorID",
			Handler:    _UsrManSrv_GetTeamsByCreatorID_Handler,
		},
		{
			MethodName: "GetTeamByName",
			Handler:    _UsrManSrv_GetTeamByName_Handler,
		},
		{
			MethodName: "UpdateTeamByID",
			Handler:    _UsrManSrv_UpdateTeamByID_Handler,
		},
		{
			MethodName: "AddMemberByID",
			Handler:    _UsrManSrv_AddMemberByID_Handler,
		},
		{
			MethodName: "RemoveMemberByID",
			Handler:    _UsrManSrv_RemoveMemberByID_Handler,
		},
		{
			MethodName: "DeleteTeamByID",
			Handler:    _UsrManSrv_DeleteTeamByID_Handler,
		},
		{
			MethodName: "CreateProject",
			Handler:    _UsrManSrv_CreateProject_Handler,
		},
		{
			MethodName: "GetProjectByID",
			Handler:    _UsrManSrv_GetProjectByID_Handler,
		},
		{
			MethodName: "GetProjtectsByTeamID",
			Handler:    _UsrManSrv_GetProjtectsByTeamID_Handler,
		},
		{
			MethodName: "UpdateProjectByID",
			Handler:    _UsrManSrv_UpdateProjectByID_Handler,
		},
		{
			MethodName: "DeleteProjectByID",
			Handler:    _UsrManSrv_DeleteProjectByID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/thanhpp/prom/pkg/usrmanrpc/usrmanService.proto",
}

func (m *GetUserByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetUserByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsrmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateUserReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateUserReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsrmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateUserResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateUserResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateUserResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetUserByUsernamePassReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserByUsernamePassReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserByUsernamePassReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pass) > 0 {
		i -= len(m.Pass)
		copy(dAtA[i:], m.Pass)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Pass)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUserByUsernamePassResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserByUsernamePassResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserByUsernamePassResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsrmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetUserByTeamIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserByTeamIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserByTeamIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetUserByTeamIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserByTeamIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserByTeamIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for iNdEx := len(m.Users) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Users[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUsrmanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateUserByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateUserByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsrmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.UserID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateUserByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateUserByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteUserByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteUserByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteUserByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteUserByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateTeamReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTeamReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateTeamReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Team != nil {
		{
			size, err := m.Team.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsrmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateTeamResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTeamResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateTeamResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTeamByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTeamByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTeamByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTeamByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTeamByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTeamByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Team != nil {
		{
			size, err := m.Team.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsrmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTeamsByCreatorIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTeamsByCreatorIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTeamsByCreatorIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatorID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.CreatorID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTeamsByCreatorIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTeamsByCreatorIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTeamsByCreatorIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Teams) > 0 {
		for iNdEx := len(m.Teams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Teams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUsrmanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTeamByNameReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTeamByNameReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTeamByNameReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TeamName) > 0 {
		i -= len(m.TeamName)
		copy(dAtA[i:], m.TeamName)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.TeamName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTeamByNameResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTeamByNameResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTeamByNameResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Teams) > 0 {
		for iNdEx := len(m.Teams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Teams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUsrmanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTeamByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTeamByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTeamByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Team != nil {
		{
			size, err := m.Team.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsrmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TeamID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTeamByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTeamByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTeamByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddMemberByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMemberByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMemberByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.TeamID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddMemberByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMemberByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMemberByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveMemberByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveMemberByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveMemberByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.TeamID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveMemberByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveMemberByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveMemberByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteTeamByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteTeamByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteTeamByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteTeamByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteTeamByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteTeamByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateProjectReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateProjectReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateProjectReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsrmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateProjectResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateProjectResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateProjectResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetProjectByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProjectByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetProjectByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProjectID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.ProjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetProjectByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProjectByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetProjectByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsrmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetProjtectsByTeamIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProjtectsByTeamIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetProjtectsByTeamIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetProjtectsByTeamIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProjtectsByTeamIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetProjtectsByTeamIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Projects) > 0 {
		for iNdEx := len(m.Projects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Projects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUsrmanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateProjectByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateProjectByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateProjectByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsrmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ProjectID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.ProjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateProjectByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateProjectByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateProjectByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteProjectByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteProjectByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteProjectByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProjectID != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.ProjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteProjectByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteProjectByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteProjectByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintUsrmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintUsrmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintUsrmanService(dAtA []byte, offset int, v uint64) int {
	offset -= sovUsrmanService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedGetUserByIDReq(r randyUsrmanService, easy bool) *GetUserByIDReq {
	this := &GetUserByIDReq{}
	this.UserID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetUserByIDResp(r randyUsrmanService, easy bool) *GetUserByIDResp {
	this := &GetUserByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if r.Intn(5) != 0 {
		this.User = entity.NewPopulatedUser(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateUserReq(r randyUsrmanService, easy bool) *CreateUserReq {
	this := &CreateUserReq{}
	if r.Intn(5) != 0 {
		this.User = entity.NewPopulatedUser(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateUserResp(r randyUsrmanService, easy bool) *CreateUserResp {
	this := &CreateUserResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetUserByUsernamePassReq(r randyUsrmanService, easy bool) *GetUserByUsernamePassReq {
	this := &GetUserByUsernamePassReq{}
	this.Username = string(randStringUsrmanService(r))
	this.Pass = string(randStringUsrmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetUserByUsernamePassResp(r randyUsrmanService, easy bool) *GetUserByUsernamePassResp {
	this := &GetUserByUsernamePassResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if r.Intn(5) != 0 {
		this.User = entity.NewPopulatedUser(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetUserByTeamIDReq(r randyUsrmanService, easy bool) *GetUserByTeamIDReq {
	this := &GetUserByTeamIDReq{}
	this.TeamID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetUserByTeamIDResp(r randyUsrmanService, easy bool) *GetUserByTeamIDResp {
	this := &GetUserByTeamIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if r.Intn(5) != 0 {
		v1 := r.Intn(5)
		this.Users = make([]*entity.User, v1)
		for i := 0; i < v1; i++ {
			this.Users[i] = entity.NewPopulatedUser(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateUserByIDReq(r randyUsrmanService, easy bool) *UpdateUserByIDReq {
	this := &UpdateUserByIDReq{}
	this.UserID = uint32(r.Uint32())
	if r.Intn(5) != 0 {
		this.User = entity.NewPopulatedUser(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateUserByIDResp(r randyUsrmanService, easy bool) *UpdateUserByIDResp {
	this := &UpdateUserByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeleteUserByIDReq(r randyUsrmanService, easy bool) *DeleteUserByIDReq {
	this := &DeleteUserByIDReq{}
	this.UserID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeleteUserByIDResp(r randyUsrmanService, easy bool) *DeleteUserByIDResp {
	this := &DeleteUserByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateTeamReq(r randyUsrmanService, easy bool) *CreateTeamReq {
	this := &CreateTeamReq{}
	if r.Intn(5) != 0 {
		this.Team = entity.NewPopulatedTeam(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateTeamResp(r randyUsrmanService, easy bool) *CreateTeamResp {
	this := &CreateTeamResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetTeamByIDReq(r randyUsrmanService, easy bool) *GetTeamByIDReq {
	this := &GetTeamByIDReq{}
	this.TeamID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetTeamByIDResp(r randyUsrmanService, easy bool) *GetTeamByIDResp {
	this := &GetTeamByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if r.Intn(5) != 0 {
		this.Team = entity.NewPopulatedTeam(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetTeamsByCreatorIDReq(r randyUsrmanService, easy bool) *GetTeamsByCreatorIDReq {
	this := &GetTeamsByCreatorIDReq{}
	this.CreatorID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetTeamsByCreatorIDResp(r randyUsrmanService, easy bool) *GetTeamsByCreatorIDResp {
	this := &GetTeamsByCreatorIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if r.Intn(5) != 0 {
		v2 := r.Intn(5)
		this.Teams = make([]*entity.Team, v2)
		for i := 0; i < v2; i++ {
			this.Teams[i] = entity.NewPopulatedTeam(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetTeamByNameReq(r randyUsrmanService, easy bool) *GetTeamByNameReq {
	this := &GetTeamByNameReq{}
	this.TeamName = string(randStringUsrmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetTeamByNameResp(r randyUsrmanService, easy bool) *GetTeamByNameResp {
	this := &GetTeamByNameResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if r.Intn(5) != 0 {
		v3 := r.Intn(5)
		this.Teams = make([]*entity.Team, v3)
		for i := 0; i < v3; i++ {
			this.Teams[i] = entity.NewPopulatedTeam(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateTeamByIDReq(r randyUsrmanService, easy bool) *UpdateTeamByIDReq {
	this := &UpdateTeamByIDReq{}
	this.TeamID = uint32(r.Uint32())
	if r.Intn(5) != 0 {
		this.Team = entity.NewPopulatedTeam(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateTeamByIDResp(r randyUsrmanService, easy bool) *UpdateTeamByIDResp {
	this := &UpdateTeamByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAddMemberByIDReq(r randyUsrmanService, easy bool) *AddMemberByIDReq {
	this := &AddMemberByIDReq{}
	this.TeamID = uint32(r.Uint32())
	this.UserID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAddMemberByIDResp(r randyUsrmanService, easy bool) *AddMemberByIDResp {
	this := &AddMemberByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRemoveMemberByIDReq(r randyUsrmanService, easy bool) *RemoveMemberByIDReq {
	this := &RemoveMemberByIDReq{}
	this.TeamID = uint32(r.Uint32())
	this.UserID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRemoveMemberByIDResp(r randyUsrmanService, easy bool) *RemoveMemberByIDResp {
	this := &RemoveMemberByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeleteTeamByIDReq(r randyUsrmanService, easy bool) *DeleteTeamByIDReq {
	this := &DeleteTeamByIDReq{}
	this.TeamID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeleteTeamByIDResp(r randyUsrmanService, easy bool) *DeleteTeamByIDResp {
	this := &DeleteTeamByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateProjectReq(r randyUsrmanService, easy bool) *CreateProjectReq {
	this := &CreateProjectReq{}
	if r.Intn(5) != 0 {
		this.Project = entity.NewPopulatedProject(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateProjectResp(r randyUsrmanService, easy bool) *CreateProjectResp {
	this := &CreateProjectResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetProjectByIDReq(r randyUsrmanService, easy bool) *GetProjectByIDReq {
	this := &GetProjectByIDReq{}
	this.ProjectID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetProjectByIDResp(r randyUsrmanService, easy bool) *GetProjectByIDResp {
	this := &GetProjectByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if r.Intn(5) != 0 {
		this.Project = entity.NewPopulatedProject(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetProjtectsByTeamIDReq(r randyUsrmanService, easy bool) *GetProjtectsByTeamIDReq {
	this := &GetProjtectsByTeamIDReq{}
	this.TeamID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetProjtectsByTeamIDResp(r randyUsrmanService, easy bool) *GetProjtectsByTeamIDResp {
	this := &GetProjtectsByTeamIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if r.Intn(5) != 0 {
		v4 := r.Intn(5)
		this.Projects = make([]*entity.Project, v4)
		for i := 0; i < v4; i++ {
			this.Projects[i] = entity.NewPopulatedProject(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateProjectByIDReq(r randyUsrmanService, easy bool) *UpdateProjectByIDReq {
	this := &UpdateProjectByIDReq{}
	this.ProjectID = uint32(r.Uint32())
	if r.Intn(5) != 0 {
		this.Project = entity.NewPopulatedProject(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateProjectByIDResp(r randyUsrmanService, easy bool) *UpdateProjectByIDResp {
	this := &UpdateProjectByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeleteProjectByIDReq(r randyUsrmanService, easy bool) *DeleteProjectByIDReq {
	this := &DeleteProjectByIDReq{}
	this.ProjectID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeleteProjectByIDResp(r randyUsrmanService, easy bool) *DeleteProjectByIDResp {
	this := &DeleteProjectByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringUsrmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyUsrmanService interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneUsrmanService(r randyUsrmanService) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringUsrmanService(r randyUsrmanService) string {
	v5 := r.Intn(100)
	tmps := make([]rune, v5)
	for i := 0; i < v5; i++ {
		tmps[i] = randUTF8RuneUsrmanService(r)
	}
	return string(tmps)
}
func randUnrecognizedUsrmanService(r randyUsrmanService, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldUsrmanService(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldUsrmanService(dAtA []byte, r randyUsrmanService, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateUsrmanService(dAtA, uint64(key))
		v6 := r.Int63()
		if r.Intn(2) == 0 {
			v6 *= -1
		}
		dAtA = encodeVarintPopulateUsrmanService(dAtA, uint64(v6))
	case 1:
		dAtA = encodeVarintPopulateUsrmanService(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateUsrmanService(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateUsrmanService(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateUsrmanService(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateUsrmanService(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *GetUserByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovUsrmanService(uint64(m.UserID))
	}
	return n
}

func (m *GetUserByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *CreateUserReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *CreateUserResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *GetUserByUsernamePassReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	l = len(m.Pass)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *GetUserByUsernamePassResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *GetUserByTeamIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovUsrmanService(uint64(m.TeamID))
	}
	return n
}

func (m *GetUserByTeamIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovUsrmanService(uint64(l))
		}
	}
	return n
}

func (m *UpdateUserByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovUsrmanService(uint64(m.UserID))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *UpdateUserByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *DeleteUserByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovUsrmanService(uint64(m.UserID))
	}
	return n
}

func (m *DeleteUserByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *CreateTeamReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Team != nil {
		l = m.Team.Size()
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *CreateTeamResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *GetTeamByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovUsrmanService(uint64(m.TeamID))
	}
	return n
}

func (m *GetTeamByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	if m.Team != nil {
		l = m.Team.Size()
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *GetTeamsByCreatorIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreatorID != 0 {
		n += 1 + sovUsrmanService(uint64(m.CreatorID))
	}
	return n
}

func (m *GetTeamsByCreatorIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	if len(m.Teams) > 0 {
		for _, e := range m.Teams {
			l = e.Size()
			n += 1 + l + sovUsrmanService(uint64(l))
		}
	}
	return n
}

func (m *GetTeamByNameReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TeamName)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *GetTeamByNameResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	if len(m.Teams) > 0 {
		for _, e := range m.Teams {
			l = e.Size()
			n += 1 + l + sovUsrmanService(uint64(l))
		}
	}
	return n
}

func (m *UpdateTeamByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovUsrmanService(uint64(m.TeamID))
	}
	if m.Team != nil {
		l = m.Team.Size()
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *UpdateTeamByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *AddMemberByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovUsrmanService(uint64(m.TeamID))
	}
	if m.UserID != 0 {
		n += 1 + sovUsrmanService(uint64(m.UserID))
	}
	return n
}

func (m *AddMemberByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *RemoveMemberByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovUsrmanService(uint64(m.TeamID))
	}
	if m.UserID != 0 {
		n += 1 + sovUsrmanService(uint64(m.UserID))
	}
	return n
}

func (m *RemoveMemberByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *DeleteTeamByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovUsrmanService(uint64(m.TeamID))
	}
	return n
}

func (m *DeleteTeamByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *CreateProjectReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *CreateProjectResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *GetProjectByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectID != 0 {
		n += 1 + sovUsrmanService(uint64(m.ProjectID))
	}
	return n
}

func (m *GetProjectByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *GetProjtectsByTeamIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovUsrmanService(uint64(m.TeamID))
	}
	return n
}

func (m *GetProjtectsByTeamIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	if len(m.Projects) > 0 {
		for _, e := range m.Projects {
			l = e.Size()
			n += 1 + l + sovUsrmanService(uint64(l))
		}
	}
	return n
}

func (m *UpdateProjectByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectID != 0 {
		n += 1 + sovUsrmanService(uint64(m.ProjectID))
	}
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *UpdateProjectByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func (m *DeleteProjectByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectID != 0 {
		n += 1 + sovUsrmanService(uint64(m.ProjectID))
	}
	return n
}

func (m *DeleteProjectByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovUsrmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUsrmanService(uint64(l))
	}
	return n
}

func sovUsrmanService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozUsrmanService(x uint64) (n int) {
	return sovUsrmanService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetUserByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &entity.User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &entity.User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateUserResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateUserResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateUserResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserByUsernamePassReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserByUsernamePassReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserByUsernamePassReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserByUsernamePassResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserByUsernamePassResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserByUsernamePassResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &entity.User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserByTeamIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserByTeamIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserByTeamIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserByTeamIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserByTeamIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserByTeamIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &entity.User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &entity.User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTeamReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTeamReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTeamReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Team == nil {
				m.Team = &entity.Team{}
			}
			if err := m.Team.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTeamResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTeamResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTeamResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTeamByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTeamByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTeamByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTeamByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTeamByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTeamByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Team == nil {
				m.Team = &entity.Team{}
			}
			if err := m.Team.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTeamsByCreatorIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTeamsByCreatorIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTeamsByCreatorIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorID", wireType)
			}
			m.CreatorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatorID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTeamsByCreatorIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTeamsByCreatorIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTeamsByCreatorIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Teams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Teams = append(m.Teams, &entity.Team{})
			if err := m.Teams[len(m.Teams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTeamByNameReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTeamByNameReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTeamByNameReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeamName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTeamByNameResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTeamByNameResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTeamByNameResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Teams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Teams = append(m.Teams, &entity.Team{})
			if err := m.Teams[len(m.Teams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTeamByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTeamByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTeamByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Team == nil {
				m.Team = &entity.Team{}
			}
			if err := m.Team.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTeamByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTeamByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTeamByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMemberByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMemberByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMemberByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMemberByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMemberByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMemberByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveMemberByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveMemberByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveMemberByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveMemberByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveMemberByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveMemberByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteTeamByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteTeamByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteTeamByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteTeamByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteTeamByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteTeamByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateProjectReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateProjectReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateProjectReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Project == nil {
				m.Project = &entity.Project{}
			}
			if err := m.Project.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateProjectResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateProjectResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateProjectResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProjectByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProjectByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProjectByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectID", wireType)
			}
			m.ProjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProjectByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProjectByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProjectByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Project == nil {
				m.Project = &entity.Project{}
			}
			if err := m.Project.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProjtectsByTeamIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProjtectsByTeamIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProjtectsByTeamIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProjtectsByTeamIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProjtectsByTeamIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProjtectsByTeamIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projects = append(m.Projects, &entity.Project{})
			if err := m.Projects[len(m.Projects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateProjectByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateProjectByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateProjectByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectID", wireType)
			}
			m.ProjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Project == nil {
				m.Project = &entity.Project{}
			}
			if err := m.Project.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateProjectByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateProjectByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateProjectByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteProjectByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteProjectByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteProjectByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectID", wireType)
			}
			m.ProjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteProjectByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteProjectByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteProjectByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsrmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsrmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsrmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUsrmanService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUsrmanService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUsrmanService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthUsrmanService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupUsrmanService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthUsrmanService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthUsrmanService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUsrmanService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupUsrmanService = fmt.Errorf("proto: unexpected end of group")
)
