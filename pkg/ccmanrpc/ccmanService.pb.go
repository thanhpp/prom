// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/thanhpp/prom/pkg/ccmanrpc/ccmanService.proto

package ccmanrpc

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	entity "github.com/thanhpp/prom/cmd/ccman/repository/entity"
	timerpc "github.com/thanhpp/prom/pkg/timerpc"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CreateCardReq struct {
	CreateCard *entity.Card `protobuf:"bytes,1,opt,name=CreateCard,proto3" json:"CreateCard,omitempty"`
}

func (m *CreateCardReq) Reset()         { *m = CreateCardReq{} }
func (m *CreateCardReq) String() string { return proto.CompactTextString(m) }
func (*CreateCardReq) ProtoMessage()    {}
func (*CreateCardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{0}
}
func (m *CreateCardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateCardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateCardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateCardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateCardReq.Merge(m, src)
}
func (m *CreateCardReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateCardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateCardReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateCardReq proto.InternalMessageInfo

func (m *CreateCardReq) GetCreateCard() *entity.Card {
	if m != nil {
		return m.CreateCard
	}
	return nil
}

type CreateCardResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *CreateCardResp) Reset()         { *m = CreateCardResp{} }
func (m *CreateCardResp) String() string { return proto.CompactTextString(m) }
func (*CreateCardResp) ProtoMessage()    {}
func (*CreateCardResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{1}
}
func (m *CreateCardResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateCardResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateCardResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateCardResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateCardResp.Merge(m, src)
}
func (m *CreateCardResp) XXX_Size() int {
	return m.Size()
}
func (m *CreateCardResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateCardResp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateCardResp proto.InternalMessageInfo

func (m *CreateCardResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CreateCardResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type GetCardByIDReq struct {
	CardID uint32 `protobuf:"varint,1,opt,name=CardID,proto3" json:"CardID,omitempty"`
}

func (m *GetCardByIDReq) Reset()         { *m = GetCardByIDReq{} }
func (m *GetCardByIDReq) String() string { return proto.CompactTextString(m) }
func (*GetCardByIDReq) ProtoMessage()    {}
func (*GetCardByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{2}
}
func (m *GetCardByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCardByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCardByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCardByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCardByIDReq.Merge(m, src)
}
func (m *GetCardByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *GetCardByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCardByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetCardByIDReq proto.InternalMessageInfo

func (m *GetCardByIDReq) GetCardID() uint32 {
	if m != nil {
		return m.CardID
	}
	return 0
}

type GetCardByIDResp struct {
	Code    int32        `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string       `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	ResCard *entity.Card `protobuf:"bytes,3,opt,name=ResCard,proto3" json:"ResCard,omitempty"`
}

func (m *GetCardByIDResp) Reset()         { *m = GetCardByIDResp{} }
func (m *GetCardByIDResp) String() string { return proto.CompactTextString(m) }
func (*GetCardByIDResp) ProtoMessage()    {}
func (*GetCardByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{3}
}
func (m *GetCardByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCardByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCardByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCardByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCardByIDResp.Merge(m, src)
}
func (m *GetCardByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *GetCardByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCardByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetCardByIDResp proto.InternalMessageInfo

func (m *GetCardByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetCardByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetCardByIDResp) GetResCard() *entity.Card {
	if m != nil {
		return m.ResCard
	}
	return nil
}

type GetCardsByDueDateReq struct {
	DueDate *timerpc.Time `protobuf:"bytes,1,opt,name=DueDate,proto3" json:"DueDate,omitempty"`
}

func (m *GetCardsByDueDateReq) Reset()         { *m = GetCardsByDueDateReq{} }
func (m *GetCardsByDueDateReq) String() string { return proto.CompactTextString(m) }
func (*GetCardsByDueDateReq) ProtoMessage()    {}
func (*GetCardsByDueDateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{4}
}
func (m *GetCardsByDueDateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCardsByDueDateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCardsByDueDateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCardsByDueDateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCardsByDueDateReq.Merge(m, src)
}
func (m *GetCardsByDueDateReq) XXX_Size() int {
	return m.Size()
}
func (m *GetCardsByDueDateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCardsByDueDateReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetCardsByDueDateReq proto.InternalMessageInfo

func (m *GetCardsByDueDateReq) GetDueDate() *timerpc.Time {
	if m != nil {
		return m.DueDate
	}
	return nil
}

type GetCardsByDueDateResp struct {
	Code    int32          `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string         `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Cards   []*entity.Card `protobuf:"bytes,3,rep,name=Cards,proto3" json:"Cards,omitempty"`
}

func (m *GetCardsByDueDateResp) Reset()         { *m = GetCardsByDueDateResp{} }
func (m *GetCardsByDueDateResp) String() string { return proto.CompactTextString(m) }
func (*GetCardsByDueDateResp) ProtoMessage()    {}
func (*GetCardsByDueDateResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{5}
}
func (m *GetCardsByDueDateResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCardsByDueDateResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCardsByDueDateResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCardsByDueDateResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCardsByDueDateResp.Merge(m, src)
}
func (m *GetCardsByDueDateResp) XXX_Size() int {
	return m.Size()
}
func (m *GetCardsByDueDateResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCardsByDueDateResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetCardsByDueDateResp proto.InternalMessageInfo

func (m *GetCardsByDueDateResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetCardsByDueDateResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetCardsByDueDateResp) GetCards() []*entity.Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

type GetCardsByAssignedToIDReq struct {
	AssignedToID uint32 `protobuf:"varint,1,opt,name=AssignedToID,proto3" json:"AssignedToID,omitempty"`
}

func (m *GetCardsByAssignedToIDReq) Reset()         { *m = GetCardsByAssignedToIDReq{} }
func (m *GetCardsByAssignedToIDReq) String() string { return proto.CompactTextString(m) }
func (*GetCardsByAssignedToIDReq) ProtoMessage()    {}
func (*GetCardsByAssignedToIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{6}
}
func (m *GetCardsByAssignedToIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCardsByAssignedToIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCardsByAssignedToIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCardsByAssignedToIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCardsByAssignedToIDReq.Merge(m, src)
}
func (m *GetCardsByAssignedToIDReq) XXX_Size() int {
	return m.Size()
}
func (m *GetCardsByAssignedToIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCardsByAssignedToIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetCardsByAssignedToIDReq proto.InternalMessageInfo

func (m *GetCardsByAssignedToIDReq) GetAssignedToID() uint32 {
	if m != nil {
		return m.AssignedToID
	}
	return 0
}

type GetCardsByAssignedToIDResp struct {
	Code    int32          `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string         `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Cards   []*entity.Card `protobuf:"bytes,3,rep,name=Cards,proto3" json:"Cards,omitempty"`
}

func (m *GetCardsByAssignedToIDResp) Reset()         { *m = GetCardsByAssignedToIDResp{} }
func (m *GetCardsByAssignedToIDResp) String() string { return proto.CompactTextString(m) }
func (*GetCardsByAssignedToIDResp) ProtoMessage()    {}
func (*GetCardsByAssignedToIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{7}
}
func (m *GetCardsByAssignedToIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCardsByAssignedToIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCardsByAssignedToIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCardsByAssignedToIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCardsByAssignedToIDResp.Merge(m, src)
}
func (m *GetCardsByAssignedToIDResp) XXX_Size() int {
	return m.Size()
}
func (m *GetCardsByAssignedToIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCardsByAssignedToIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetCardsByAssignedToIDResp proto.InternalMessageInfo

func (m *GetCardsByAssignedToIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetCardsByAssignedToIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetCardsByAssignedToIDResp) GetCards() []*entity.Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

type GetCardsByCreatorIDReq struct {
}

func (m *GetCardsByCreatorIDReq) Reset()         { *m = GetCardsByCreatorIDReq{} }
func (m *GetCardsByCreatorIDReq) String() string { return proto.CompactTextString(m) }
func (*GetCardsByCreatorIDReq) ProtoMessage()    {}
func (*GetCardsByCreatorIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{8}
}
func (m *GetCardsByCreatorIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCardsByCreatorIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCardsByCreatorIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCardsByCreatorIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCardsByCreatorIDReq.Merge(m, src)
}
func (m *GetCardsByCreatorIDReq) XXX_Size() int {
	return m.Size()
}
func (m *GetCardsByCreatorIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCardsByCreatorIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetCardsByCreatorIDReq proto.InternalMessageInfo

type GetCardsByCreatorIDResp struct {
	Code    int32          `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string         `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Cards   []*entity.Card `protobuf:"bytes,3,rep,name=Cards,proto3" json:"Cards,omitempty"`
}

func (m *GetCardsByCreatorIDResp) Reset()         { *m = GetCardsByCreatorIDResp{} }
func (m *GetCardsByCreatorIDResp) String() string { return proto.CompactTextString(m) }
func (*GetCardsByCreatorIDResp) ProtoMessage()    {}
func (*GetCardsByCreatorIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{9}
}
func (m *GetCardsByCreatorIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCardsByCreatorIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCardsByCreatorIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCardsByCreatorIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCardsByCreatorIDResp.Merge(m, src)
}
func (m *GetCardsByCreatorIDResp) XXX_Size() int {
	return m.Size()
}
func (m *GetCardsByCreatorIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCardsByCreatorIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetCardsByCreatorIDResp proto.InternalMessageInfo

func (m *GetCardsByCreatorIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetCardsByCreatorIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetCardsByCreatorIDResp) GetCards() []*entity.Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

type GetCardsByColumnIDReq struct {
	ColumnID uint32 `protobuf:"varint,1,opt,name=ColumnID,proto3" json:"ColumnID,omitempty"`
}

func (m *GetCardsByColumnIDReq) Reset()         { *m = GetCardsByColumnIDReq{} }
func (m *GetCardsByColumnIDReq) String() string { return proto.CompactTextString(m) }
func (*GetCardsByColumnIDReq) ProtoMessage()    {}
func (*GetCardsByColumnIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{10}
}
func (m *GetCardsByColumnIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCardsByColumnIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCardsByColumnIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCardsByColumnIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCardsByColumnIDReq.Merge(m, src)
}
func (m *GetCardsByColumnIDReq) XXX_Size() int {
	return m.Size()
}
func (m *GetCardsByColumnIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCardsByColumnIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetCardsByColumnIDReq proto.InternalMessageInfo

func (m *GetCardsByColumnIDReq) GetColumnID() uint32 {
	if m != nil {
		return m.ColumnID
	}
	return 0
}

type GetCardsByColumnIDResp struct {
	Code    int32          `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string         `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Cards   []*entity.Card `protobuf:"bytes,3,rep,name=Cards,proto3" json:"Cards,omitempty"`
}

func (m *GetCardsByColumnIDResp) Reset()         { *m = GetCardsByColumnIDResp{} }
func (m *GetCardsByColumnIDResp) String() string { return proto.CompactTextString(m) }
func (*GetCardsByColumnIDResp) ProtoMessage()    {}
func (*GetCardsByColumnIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{11}
}
func (m *GetCardsByColumnIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCardsByColumnIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCardsByColumnIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCardsByColumnIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCardsByColumnIDResp.Merge(m, src)
}
func (m *GetCardsByColumnIDResp) XXX_Size() int {
	return m.Size()
}
func (m *GetCardsByColumnIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCardsByColumnIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetCardsByColumnIDResp proto.InternalMessageInfo

func (m *GetCardsByColumnIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetCardsByColumnIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetCardsByColumnIDResp) GetCards() []*entity.Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

type UpdateCardByIDReq struct {
	CardID     uint32       `protobuf:"varint,1,opt,name=CardID,proto3" json:"CardID,omitempty"`
	UpdateCard *entity.Card `protobuf:"bytes,2,opt,name=UpdateCard,proto3" json:"UpdateCard,omitempty"`
}

func (m *UpdateCardByIDReq) Reset()         { *m = UpdateCardByIDReq{} }
func (m *UpdateCardByIDReq) String() string { return proto.CompactTextString(m) }
func (*UpdateCardByIDReq) ProtoMessage()    {}
func (*UpdateCardByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{12}
}
func (m *UpdateCardByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCardByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCardByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCardByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCardByIDReq.Merge(m, src)
}
func (m *UpdateCardByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCardByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCardByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCardByIDReq proto.InternalMessageInfo

func (m *UpdateCardByIDReq) GetCardID() uint32 {
	if m != nil {
		return m.CardID
	}
	return 0
}

func (m *UpdateCardByIDReq) GetUpdateCard() *entity.Card {
	if m != nil {
		return m.UpdateCard
	}
	return nil
}

type UpdateCardByIDResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *UpdateCardByIDResp) Reset()         { *m = UpdateCardByIDResp{} }
func (m *UpdateCardByIDResp) String() string { return proto.CompactTextString(m) }
func (*UpdateCardByIDResp) ProtoMessage()    {}
func (*UpdateCardByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{13}
}
func (m *UpdateCardByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCardByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCardByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCardByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCardByIDResp.Merge(m, src)
}
func (m *UpdateCardByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCardByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCardByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCardByIDResp proto.InternalMessageInfo

func (m *UpdateCardByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *UpdateCardByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type DeleteCardByIDReq struct {
	CardID uint32 `protobuf:"varint,1,opt,name=CardID,proto3" json:"CardID,omitempty"`
}

func (m *DeleteCardByIDReq) Reset()         { *m = DeleteCardByIDReq{} }
func (m *DeleteCardByIDReq) String() string { return proto.CompactTextString(m) }
func (*DeleteCardByIDReq) ProtoMessage()    {}
func (*DeleteCardByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{14}
}
func (m *DeleteCardByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteCardByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteCardByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteCardByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteCardByIDReq.Merge(m, src)
}
func (m *DeleteCardByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteCardByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteCardByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteCardByIDReq proto.InternalMessageInfo

func (m *DeleteCardByIDReq) GetCardID() uint32 {
	if m != nil {
		return m.CardID
	}
	return 0
}

type DeleteCardByIDResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *DeleteCardByIDResp) Reset()         { *m = DeleteCardByIDResp{} }
func (m *DeleteCardByIDResp) String() string { return proto.CompactTextString(m) }
func (*DeleteCardByIDResp) ProtoMessage()    {}
func (*DeleteCardByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{15}
}
func (m *DeleteCardByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteCardByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteCardByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteCardByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteCardByIDResp.Merge(m, src)
}
func (m *DeleteCardByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *DeleteCardByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteCardByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteCardByIDResp proto.InternalMessageInfo

func (m *DeleteCardByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DeleteCardByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type CreateColumnReq struct {
	CreateColumn *entity.Column `protobuf:"bytes,1,opt,name=CreateColumn,proto3" json:"CreateColumn,omitempty"`
}

func (m *CreateColumnReq) Reset()         { *m = CreateColumnReq{} }
func (m *CreateColumnReq) String() string { return proto.CompactTextString(m) }
func (*CreateColumnReq) ProtoMessage()    {}
func (*CreateColumnReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{16}
}
func (m *CreateColumnReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateColumnReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateColumnReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateColumnReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateColumnReq.Merge(m, src)
}
func (m *CreateColumnReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateColumnReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateColumnReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateColumnReq proto.InternalMessageInfo

func (m *CreateColumnReq) GetCreateColumn() *entity.Column {
	if m != nil {
		return m.CreateColumn
	}
	return nil
}

type CreateColumnResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *CreateColumnResp) Reset()         { *m = CreateColumnResp{} }
func (m *CreateColumnResp) String() string { return proto.CompactTextString(m) }
func (*CreateColumnResp) ProtoMessage()    {}
func (*CreateColumnResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{17}
}
func (m *CreateColumnResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateColumnResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateColumnResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateColumnResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateColumnResp.Merge(m, src)
}
func (m *CreateColumnResp) XXX_Size() int {
	return m.Size()
}
func (m *CreateColumnResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateColumnResp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateColumnResp proto.InternalMessageInfo

func (m *CreateColumnResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CreateColumnResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type GetColumnByIDReq struct {
	ColumnID uint32 `protobuf:"varint,1,opt,name=ColumnID,proto3" json:"ColumnID,omitempty"`
}

func (m *GetColumnByIDReq) Reset()         { *m = GetColumnByIDReq{} }
func (m *GetColumnByIDReq) String() string { return proto.CompactTextString(m) }
func (*GetColumnByIDReq) ProtoMessage()    {}
func (*GetColumnByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{18}
}
func (m *GetColumnByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetColumnByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetColumnByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetColumnByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetColumnByIDReq.Merge(m, src)
}
func (m *GetColumnByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *GetColumnByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetColumnByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetColumnByIDReq proto.InternalMessageInfo

func (m *GetColumnByIDReq) GetColumnID() uint32 {
	if m != nil {
		return m.ColumnID
	}
	return 0
}

type GetColumnByIDResp struct {
	Code    int32          `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string         `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Column  *entity.Column `protobuf:"bytes,3,opt,name=Column,proto3" json:"Column,omitempty"`
}

func (m *GetColumnByIDResp) Reset()         { *m = GetColumnByIDResp{} }
func (m *GetColumnByIDResp) String() string { return proto.CompactTextString(m) }
func (*GetColumnByIDResp) ProtoMessage()    {}
func (*GetColumnByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{19}
}
func (m *GetColumnByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetColumnByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetColumnByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetColumnByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetColumnByIDResp.Merge(m, src)
}
func (m *GetColumnByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *GetColumnByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetColumnByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetColumnByIDResp proto.InternalMessageInfo

func (m *GetColumnByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetColumnByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetColumnByIDResp) GetColumn() *entity.Column {
	if m != nil {
		return m.Column
	}
	return nil
}

type GetColumnsByTitleReq struct {
	Title string `protobuf:"bytes,1,opt,name=Title,proto3" json:"Title,omitempty"`
}

func (m *GetColumnsByTitleReq) Reset()         { *m = GetColumnsByTitleReq{} }
func (m *GetColumnsByTitleReq) String() string { return proto.CompactTextString(m) }
func (*GetColumnsByTitleReq) ProtoMessage()    {}
func (*GetColumnsByTitleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{20}
}
func (m *GetColumnsByTitleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetColumnsByTitleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetColumnsByTitleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetColumnsByTitleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetColumnsByTitleReq.Merge(m, src)
}
func (m *GetColumnsByTitleReq) XXX_Size() int {
	return m.Size()
}
func (m *GetColumnsByTitleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetColumnsByTitleReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetColumnsByTitleReq proto.InternalMessageInfo

func (m *GetColumnsByTitleReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

type GetColumnsByTitleResp struct {
	Code    int32            `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string           `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Columns []*entity.Column `protobuf:"bytes,3,rep,name=Columns,proto3" json:"Columns,omitempty"`
}

func (m *GetColumnsByTitleResp) Reset()         { *m = GetColumnsByTitleResp{} }
func (m *GetColumnsByTitleResp) String() string { return proto.CompactTextString(m) }
func (*GetColumnsByTitleResp) ProtoMessage()    {}
func (*GetColumnsByTitleResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{21}
}
func (m *GetColumnsByTitleResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetColumnsByTitleResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetColumnsByTitleResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetColumnsByTitleResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetColumnsByTitleResp.Merge(m, src)
}
func (m *GetColumnsByTitleResp) XXX_Size() int {
	return m.Size()
}
func (m *GetColumnsByTitleResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetColumnsByTitleResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetColumnsByTitleResp proto.InternalMessageInfo

func (m *GetColumnsByTitleResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetColumnsByTitleResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetColumnsByTitleResp) GetColumns() []*entity.Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

type GetColumnsByProjectIDReq struct {
	ProjectID uint32 `protobuf:"varint,1,opt,name=ProjectID,proto3" json:"ProjectID,omitempty"`
}

func (m *GetColumnsByProjectIDReq) Reset()         { *m = GetColumnsByProjectIDReq{} }
func (m *GetColumnsByProjectIDReq) String() string { return proto.CompactTextString(m) }
func (*GetColumnsByProjectIDReq) ProtoMessage()    {}
func (*GetColumnsByProjectIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{22}
}
func (m *GetColumnsByProjectIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetColumnsByProjectIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetColumnsByProjectIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetColumnsByProjectIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetColumnsByProjectIDReq.Merge(m, src)
}
func (m *GetColumnsByProjectIDReq) XXX_Size() int {
	return m.Size()
}
func (m *GetColumnsByProjectIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetColumnsByProjectIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetColumnsByProjectIDReq proto.InternalMessageInfo

func (m *GetColumnsByProjectIDReq) GetProjectID() uint32 {
	if m != nil {
		return m.ProjectID
	}
	return 0
}

type GetColumnsByProjectIDResp struct {
	Code    int32            `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string           `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Columns []*entity.Column `protobuf:"bytes,3,rep,name=Columns,proto3" json:"Columns,omitempty"`
}

func (m *GetColumnsByProjectIDResp) Reset()         { *m = GetColumnsByProjectIDResp{} }
func (m *GetColumnsByProjectIDResp) String() string { return proto.CompactTextString(m) }
func (*GetColumnsByProjectIDResp) ProtoMessage()    {}
func (*GetColumnsByProjectIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{23}
}
func (m *GetColumnsByProjectIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetColumnsByProjectIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetColumnsByProjectIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetColumnsByProjectIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetColumnsByProjectIDResp.Merge(m, src)
}
func (m *GetColumnsByProjectIDResp) XXX_Size() int {
	return m.Size()
}
func (m *GetColumnsByProjectIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetColumnsByProjectIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetColumnsByProjectIDResp proto.InternalMessageInfo

func (m *GetColumnsByProjectIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetColumnsByProjectIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetColumnsByProjectIDResp) GetColumns() []*entity.Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

type UpdateColumnByIDReq struct {
	ColumnID uint32         `protobuf:"varint,1,opt,name=ColumnID,proto3" json:"ColumnID,omitempty"`
	Column   *entity.Column `protobuf:"bytes,2,opt,name=Column,proto3" json:"Column,omitempty"`
}

func (m *UpdateColumnByIDReq) Reset()         { *m = UpdateColumnByIDReq{} }
func (m *UpdateColumnByIDReq) String() string { return proto.CompactTextString(m) }
func (*UpdateColumnByIDReq) ProtoMessage()    {}
func (*UpdateColumnByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{24}
}
func (m *UpdateColumnByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateColumnByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateColumnByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateColumnByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateColumnByIDReq.Merge(m, src)
}
func (m *UpdateColumnByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateColumnByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateColumnByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateColumnByIDReq proto.InternalMessageInfo

func (m *UpdateColumnByIDReq) GetColumnID() uint32 {
	if m != nil {
		return m.ColumnID
	}
	return 0
}

func (m *UpdateColumnByIDReq) GetColumn() *entity.Column {
	if m != nil {
		return m.Column
	}
	return nil
}

type UpdateColumnByIDResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *UpdateColumnByIDResp) Reset()         { *m = UpdateColumnByIDResp{} }
func (m *UpdateColumnByIDResp) String() string { return proto.CompactTextString(m) }
func (*UpdateColumnByIDResp) ProtoMessage()    {}
func (*UpdateColumnByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{25}
}
func (m *UpdateColumnByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateColumnByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateColumnByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateColumnByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateColumnByIDResp.Merge(m, src)
}
func (m *UpdateColumnByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *UpdateColumnByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateColumnByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateColumnByIDResp proto.InternalMessageInfo

func (m *UpdateColumnByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *UpdateColumnByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type DeleteColumnByIDReq struct {
	ColumnID uint32 `protobuf:"varint,1,opt,name=ColumnID,proto3" json:"ColumnID,omitempty"`
}

func (m *DeleteColumnByIDReq) Reset()         { *m = DeleteColumnByIDReq{} }
func (m *DeleteColumnByIDReq) String() string { return proto.CompactTextString(m) }
func (*DeleteColumnByIDReq) ProtoMessage()    {}
func (*DeleteColumnByIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{26}
}
func (m *DeleteColumnByIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteColumnByIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteColumnByIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteColumnByIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteColumnByIDReq.Merge(m, src)
}
func (m *DeleteColumnByIDReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteColumnByIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteColumnByIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteColumnByIDReq proto.InternalMessageInfo

func (m *DeleteColumnByIDReq) GetColumnID() uint32 {
	if m != nil {
		return m.ColumnID
	}
	return 0
}

type DeleteColumnByIDResp struct {
	Code    int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *DeleteColumnByIDResp) Reset()         { *m = DeleteColumnByIDResp{} }
func (m *DeleteColumnByIDResp) String() string { return proto.CompactTextString(m) }
func (*DeleteColumnByIDResp) ProtoMessage()    {}
func (*DeleteColumnByIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de712ab1145d6aa, []int{27}
}
func (m *DeleteColumnByIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteColumnByIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteColumnByIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteColumnByIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteColumnByIDResp.Merge(m, src)
}
func (m *DeleteColumnByIDResp) XXX_Size() int {
	return m.Size()
}
func (m *DeleteColumnByIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteColumnByIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteColumnByIDResp proto.InternalMessageInfo

func (m *DeleteColumnByIDResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DeleteColumnByIDResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*CreateCardReq)(nil), "ccmanrpc.CreateCardReq")
	proto.RegisterType((*CreateCardResp)(nil), "ccmanrpc.CreateCardResp")
	proto.RegisterType((*GetCardByIDReq)(nil), "ccmanrpc.GetCardByIDReq")
	proto.RegisterType((*GetCardByIDResp)(nil), "ccmanrpc.GetCardByIDResp")
	proto.RegisterType((*GetCardsByDueDateReq)(nil), "ccmanrpc.GetCardsByDueDateReq")
	proto.RegisterType((*GetCardsByDueDateResp)(nil), "ccmanrpc.GetCardsByDueDateResp")
	proto.RegisterType((*GetCardsByAssignedToIDReq)(nil), "ccmanrpc.GetCardsByAssignedToIDReq")
	proto.RegisterType((*GetCardsByAssignedToIDResp)(nil), "ccmanrpc.GetCardsByAssignedToIDResp")
	proto.RegisterType((*GetCardsByCreatorIDReq)(nil), "ccmanrpc.GetCardsByCreatorIDReq")
	proto.RegisterType((*GetCardsByCreatorIDResp)(nil), "ccmanrpc.GetCardsByCreatorIDResp")
	proto.RegisterType((*GetCardsByColumnIDReq)(nil), "ccmanrpc.GetCardsByColumnIDReq")
	proto.RegisterType((*GetCardsByColumnIDResp)(nil), "ccmanrpc.GetCardsByColumnIDResp")
	proto.RegisterType((*UpdateCardByIDReq)(nil), "ccmanrpc.UpdateCardByIDReq")
	proto.RegisterType((*UpdateCardByIDResp)(nil), "ccmanrpc.UpdateCardByIDResp")
	proto.RegisterType((*DeleteCardByIDReq)(nil), "ccmanrpc.DeleteCardByIDReq")
	proto.RegisterType((*DeleteCardByIDResp)(nil), "ccmanrpc.DeleteCardByIDResp")
	proto.RegisterType((*CreateColumnReq)(nil), "ccmanrpc.CreateColumnReq")
	proto.RegisterType((*CreateColumnResp)(nil), "ccmanrpc.CreateColumnResp")
	proto.RegisterType((*GetColumnByIDReq)(nil), "ccmanrpc.GetColumnByIDReq")
	proto.RegisterType((*GetColumnByIDResp)(nil), "ccmanrpc.GetColumnByIDResp")
	proto.RegisterType((*GetColumnsByTitleReq)(nil), "ccmanrpc.GetColumnsByTitleReq")
	proto.RegisterType((*GetColumnsByTitleResp)(nil), "ccmanrpc.GetColumnsByTitleResp")
	proto.RegisterType((*GetColumnsByProjectIDReq)(nil), "ccmanrpc.GetColumnsByProjectIDReq")
	proto.RegisterType((*GetColumnsByProjectIDResp)(nil), "ccmanrpc.GetColumnsByProjectIDResp")
	proto.RegisterType((*UpdateColumnByIDReq)(nil), "ccmanrpc.UpdateColumnByIDReq")
	proto.RegisterType((*UpdateColumnByIDResp)(nil), "ccmanrpc.UpdateColumnByIDResp")
	proto.RegisterType((*DeleteColumnByIDReq)(nil), "ccmanrpc.DeleteColumnByIDReq")
	proto.RegisterType((*DeleteColumnByIDResp)(nil), "ccmanrpc.DeleteColumnByIDResp")
}

func init() {
	proto.RegisterFile("github.com/thanhpp/prom/pkg/ccmanrpc/ccmanService.proto", fileDescriptor_8de712ab1145d6aa)
}

var fileDescriptor_8de712ab1145d6aa = []byte{
	// 917 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x4f, 0x8f, 0xdb, 0x44,
	0x14, 0x5f, 0x77, 0xd9, 0x4d, 0xf3, 0xda, 0xa4, 0xd9, 0xd9, 0xd0, 0x66, 0xa7, 0xc5, 0x84, 0xe9,
	0x4a, 0x44, 0xfc, 0x71, 0x44, 0x8b, 0x80, 0x13, 0x81, 0x24, 0x55, 0xa9, 0x50, 0x25, 0x08, 0x01,
	0xa4, 0xf6, 0x82, 0x37, 0x19, 0xb2, 0x66, 0x93, 0x78, 0xea, 0x71, 0x90, 0xf2, 0x11, 0xb8, 0xf1,
	0x31, 0xf8, 0x08, 0x1c, 0x39, 0x72, 0xec, 0x91, 0x63, 0x37, 0xfb, 0x05, 0x38, 0x72, 0x44, 0x1e,
	0x8f, 0xe3, 0x19, 0xdb, 0xf9, 0xe3, 0x4a, 0x39, 0xc5, 0xcf, 0xef, 0xf7, 0xfe, 0xcc, 0x9b, 0xf7,
	0x7e, 0xcf, 0x81, 0x4f, 0x47, 0x8e, 0x7f, 0x3e, 0x3b, 0xb3, 0x06, 0xee, 0xa4, 0xe9, 0x9f, 0xdb,
	0xd3, 0x73, 0xc6, 0x9a, 0xcc, 0x73, 0x27, 0x4d, 0x76, 0x31, 0x6a, 0x0e, 0x06, 0x13, 0x7b, 0xea,
	0xb1, 0x41, 0xf8, 0xf0, 0x1d, 0xf5, 0x7e, 0x75, 0x06, 0xd4, 0x62, 0x9e, 0xeb, 0xbb, 0xe8, 0x7a,
	0xa4, 0xc4, 0x1f, 0x2a, 0x2e, 0x46, 0xee, 0xc8, 0x6d, 0x0a, 0xc0, 0xd9, 0xec, 0x67, 0x21, 0x09,
	0x41, 0x3c, 0x85, 0x86, 0xd8, 0x5a, 0x17, 0xd1, 0x77, 0x26, 0x34, 0x08, 0x18, 0xfc, 0x4a, 0xfc,
	0x27, 0xdb, 0x67, 0xf8, 0x68, 0xea, 0x3b, 0xfe, 0x3c, 0xb4, 0x23, 0x2d, 0x28, 0x75, 0x3c, 0x6a,
	0xfb, 0xb4, 0x63, 0x7b, 0xc3, 0x1e, 0x7d, 0x81, 0x2c, 0x80, 0xf8, 0x45, 0xcd, 0xa8, 0x1b, 0x8d,
	0x1b, 0x0f, 0xca, 0x56, 0xe4, 0xc1, 0x12, 0x30, 0x05, 0x41, 0x3e, 0x87, 0xb2, 0xea, 0x80, 0x33,
	0x84, 0xe0, 0x8d, 0x8e, 0x3b, 0xa4, 0xc2, 0xf6, 0xa0, 0x27, 0x9e, 0x51, 0x0d, 0x0a, 0x4f, 0x29,
	0xe7, 0xf6, 0x88, 0xd6, 0xae, 0xd5, 0x8d, 0x46, 0xb1, 0x17, 0x89, 0xa4, 0x01, 0xe5, 0xc7, 0xd4,
	0x0f, 0x8c, 0xdb, 0xf3, 0x27, 0xdd, 0x20, 0x83, 0xdb, 0x70, 0x18, 0x88, 0x4f, 0xba, 0xc2, 0x43,
	0xa9, 0x27, 0x25, 0xe2, 0xc0, 0x2d, 0x0d, 0x99, 0x37, 0x14, 0x6a, 0x40, 0xa1, 0x47, 0xb9, 0x38,
	0xd7, 0x7e, 0xe6, 0xb9, 0x22, 0x35, 0x69, 0x41, 0x55, 0x86, 0xe2, 0xed, 0x79, 0x77, 0x46, 0xbb,
	0xb6, 0x4f, 0x83, 0xd4, 0xde, 0x85, 0x82, 0x94, 0x64, 0x65, 0x4a, 0x96, 0xbc, 0x0b, 0xab, 0xef,
	0x4c, 0x68, 0x2f, 0xd2, 0x92, 0x0b, 0x78, 0x33, 0xc3, 0x41, 0xee, 0x8c, 0x4f, 0xe1, 0x40, 0xf8,
	0xa8, 0xed, 0xd7, 0xf7, 0x33, 0xf2, 0x0d, 0x95, 0xa4, 0x05, 0x27, 0x71, 0xb0, 0x2f, 0x39, 0x77,
	0x46, 0x53, 0x3a, 0xec, 0xbb, 0x61, 0x35, 0x09, 0xdc, 0x54, 0x5f, 0xc9, 0x9a, 0x6a, 0xef, 0x08,
	0x03, 0xbc, 0xca, 0xc1, 0x8e, 0x52, 0xae, 0xc1, 0xed, 0x38, 0xa2, 0xe8, 0x1f, 0xd7, 0x13, 0xf9,
	0x92, 0x09, 0xdc, 0xc9, 0xd4, 0xec, 0x28, 0x91, 0x87, 0xea, 0x45, 0x75, 0xdc, 0xf1, 0x6c, 0x32,
	0x0d, 0xeb, 0x86, 0xe1, 0x7a, 0x24, 0xca, 0x9a, 0x2d, 0x65, 0x32, 0xd6, 0xb2, 0x5f, 0x1a, 0xed,
	0x28, 0xc5, 0xe7, 0x70, 0xf4, 0x3d, 0x1b, 0xca, 0x09, 0xdb, 0x30, 0x24, 0xc1, 0xf8, 0xc6, 0x60,
	0x11, 0x2f, 0x63, 0x7c, 0x63, 0x04, 0x69, 0x03, 0x4a, 0x3a, 0xcf, 0x3d, 0xc2, 0xef, 0xc3, 0x51,
	0x97, 0x8e, 0xe9, 0x56, 0x09, 0x06, 0x01, 0x93, 0xe0, 0xdc, 0x01, 0x1f, 0xc3, 0x2d, 0xc9, 0x39,
	0xa2, 0xf6, 0x41, 0xb8, 0x8f, 0xe1, 0xa6, 0xfa, 0x4a, 0x8e, 0x67, 0x45, 0x39, 0x79, 0x08, 0xd5,
	0x50, 0xe4, 0x0b, 0xa8, 0xe8, 0x8e, 0x72, 0xa7, 0x62, 0x41, 0x25, 0x68, 0x05, 0x61, 0x1e, 0x1d,
	0x7d, 0x5d, 0xeb, 0x5c, 0xc0, 0x51, 0x02, 0xff, 0x1a, 0x34, 0x76, 0x28, 0x0f, 0xb9, 0xbf, 0xe2,
	0x90, 0x52, 0x4f, 0x3e, 0x08, 0x69, 0x4c, 0x08, 0xbc, 0x3d, 0xef, 0x3b, 0xfe, 0x58, 0xd0, 0x58,
	0x15, 0x0e, 0xc4, 0xb3, 0x08, 0x58, 0xec, 0x85, 0x02, 0x79, 0x11, 0x8e, 0x42, 0x02, 0x9d, 0x3b,
	0xbd, 0xf7, 0xa0, 0x20, 0x7d, 0xc8, 0xb6, 0x4e, 0xe7, 0x17, 0x01, 0xc8, 0x67, 0x50, 0x53, 0x43,
	0x7e, 0xe3, 0xb9, 0xbf, 0xd0, 0x81, 0x1f, 0x56, 0xf1, 0x1e, 0x14, 0x97, 0xb2, 0x2c, 0x63, 0xfc,
	0x82, 0xcc, 0x42, 0xce, 0xcb, 0xb0, 0xdc, 0x69, 0xc2, 0xcf, 0xe1, 0x58, 0x8e, 0xcb, 0xb6, 0x37,
	0xae, 0x5c, 0xd7, 0xb5, 0x0d, 0xd7, 0xd5, 0x85, 0x6a, 0xda, 0x79, 0xee, 0x8e, 0xfc, 0x08, 0x8e,
	0xe5, 0x80, 0x6d, 0xdd, 0x94, 0x5d, 0xa8, 0xa6, 0x4d, 0xf2, 0x06, 0x7e, 0xf0, 0x5b, 0x11, 0x8a,
	0x9d, 0xce, 0x53, 0x7b, 0x6a, 0x8f, 0xa8, 0x87, 0x5a, 0xea, 0x77, 0x04, 0xba, 0xa3, 0x1c, 0x5a,
	0xfd, 0xdc, 0xc0, 0xb5, 0x6c, 0x05, 0x67, 0xa8, 0x0d, 0x37, 0x94, 0x75, 0x8f, 0x14, 0xa0, 0xfe,
	0xbd, 0x80, 0x4f, 0x56, 0x68, 0x38, 0x43, 0xfd, 0x70, 0xda, 0xb4, 0x35, 0x8c, 0xcc, 0x14, 0x5e,
	0x5b, 0xf2, 0xf8, 0xed, 0xb5, 0x7a, 0xce, 0xd0, 0x40, 0xa5, 0x7f, 0x75, 0x5d, 0xa2, 0xfb, 0x59,
	0xa6, 0x89, 0x8d, 0x8c, 0x4f, 0x37, 0x83, 0x38, 0x43, 0xcf, 0xe0, 0x38, 0x63, 0x0f, 0xa2, 0x7a,
	0x96, 0xb1, 0xba, 0x40, 0xf1, 0x3b, 0x1b, 0x10, 0x9c, 0xa1, 0x1f, 0x01, 0xa5, 0xf7, 0x17, 0xca,
	0x3c, 0xb7, 0xb2, 0x12, 0x71, 0x7d, 0x3d, 0x80, 0x33, 0xf4, 0x35, 0x94, 0xf5, 0x6d, 0x82, 0xee,
	0xc6, 0x36, 0xa9, 0x25, 0x86, 0xef, 0xad, 0x56, 0x86, 0xce, 0xf4, 0x4d, 0xa1, 0x3a, 0x4b, 0x2d,
	0x1c, 0xd5, 0x59, 0xc6, 0x82, 0x79, 0xa4, 0xef, 0x07, 0x74, 0x92, 0xea, 0xbb, 0x68, 0x95, 0x60,
	0xbc, 0x4a, 0xc5, 0x19, 0xfa, 0x0a, 0x4a, 0x1a, 0x7d, 0x23, 0xac, 0xd7, 0x44, 0x1d, 0x39, 0x7c,
	0x77, 0xa5, 0x2e, 0x6e, 0x4d, 0x8d, 0x6d, 0x93, 0xad, 0x99, 0x24, 0xee, 0x64, 0x6b, 0xa6, 0xa9,
	0xfa, 0x27, 0x9d, 0xc3, 0x97, 0xb4, 0x88, 0x48, 0xb6, 0xa5, 0xca, 0xb8, 0xf8, 0xfe, 0x46, 0x0c,
	0x67, 0xe8, 0x5b, 0xa8, 0x24, 0x49, 0x0a, 0xbd, 0x95, 0xba, 0x47, 0xad, 0x0e, 0xe6, 0x3a, 0x75,
	0xe8, 0x32, 0x49, 0x3f, 0xaa, 0xcb, 0x0c, 0x36, 0x53, 0x5d, 0x66, 0x31, 0x57, 0xfb, 0x87, 0x57,
	0x97, 0xa6, 0xf1, 0xef, 0xa5, 0x69, 0xfc, 0x77, 0x69, 0x1a, 0x7f, 0x2c, 0x4c, 0xe3, 0xcf, 0x85,
	0x69, 0xfc, 0xb5, 0x30, 0xf7, 0xfe, 0x5e, 0x98, 0xc6, 0xcb, 0x85, 0x69, 0xbc, 0x5a, 0x98, 0xc6,
	0xef, 0x57, 0xe6, 0xde, 0xcb, 0x2b, 0x73, 0xef, 0x9f, 0x2b, 0x73, 0xef, 0xd9, 0xe9, 0x36, 0x7f,
	0xa0, 0xce, 0x0e, 0xc5, 0xbf, 0xa6, 0x87, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0x2a, 0x3d, 0xff,
	0x60, 0x11, 0x0e, 0x00, 0x00,
}

func (this *CreateCardReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CreateCardReq)
	if !ok {
		that2, ok := that.(CreateCardReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CreateCardReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CreateCardReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CreateCardReq but is not nil && this == nil")
	}
	if !this.CreateCard.Equal(that1.CreateCard) {
		return fmt.Errorf("CreateCard this(%v) Not Equal that(%v)", this.CreateCard, that1.CreateCard)
	}
	return nil
}
func (this *CreateCardReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateCardReq)
	if !ok {
		that2, ok := that.(CreateCardReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CreateCard.Equal(that1.CreateCard) {
		return false
	}
	return true
}
func (this *CreateCardResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CreateCardResp)
	if !ok {
		that2, ok := that.(CreateCardResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CreateCardResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CreateCardResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CreateCardResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *CreateCardResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateCardResp)
	if !ok {
		that2, ok := that.(CreateCardResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *GetCardByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetCardByIDReq)
	if !ok {
		that2, ok := that.(GetCardByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetCardByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetCardByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetCardByIDReq but is not nil && this == nil")
	}
	if this.CardID != that1.CardID {
		return fmt.Errorf("CardID this(%v) Not Equal that(%v)", this.CardID, that1.CardID)
	}
	return nil
}
func (this *GetCardByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetCardByIDReq)
	if !ok {
		that2, ok := that.(GetCardByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CardID != that1.CardID {
		return false
	}
	return true
}
func (this *GetCardByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetCardByIDResp)
	if !ok {
		that2, ok := that.(GetCardByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetCardByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetCardByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetCardByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if !this.ResCard.Equal(that1.ResCard) {
		return fmt.Errorf("ResCard this(%v) Not Equal that(%v)", this.ResCard, that1.ResCard)
	}
	return nil
}
func (this *GetCardByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetCardByIDResp)
	if !ok {
		that2, ok := that.(GetCardByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if !this.ResCard.Equal(that1.ResCard) {
		return false
	}
	return true
}
func (this *GetCardsByDueDateReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetCardsByDueDateReq)
	if !ok {
		that2, ok := that.(GetCardsByDueDateReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetCardsByDueDateReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetCardsByDueDateReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetCardsByDueDateReq but is not nil && this == nil")
	}
	if !this.DueDate.Equal(that1.DueDate) {
		return fmt.Errorf("DueDate this(%v) Not Equal that(%v)", this.DueDate, that1.DueDate)
	}
	return nil
}
func (this *GetCardsByDueDateReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetCardsByDueDateReq)
	if !ok {
		that2, ok := that.(GetCardsByDueDateReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DueDate.Equal(that1.DueDate) {
		return false
	}
	return true
}
func (this *GetCardsByDueDateResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetCardsByDueDateResp)
	if !ok {
		that2, ok := that.(GetCardsByDueDateResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetCardsByDueDateResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetCardsByDueDateResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetCardsByDueDateResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if len(this.Cards) != len(that1.Cards) {
		return fmt.Errorf("Cards this(%v) Not Equal that(%v)", len(this.Cards), len(that1.Cards))
	}
	for i := range this.Cards {
		if !this.Cards[i].Equal(that1.Cards[i]) {
			return fmt.Errorf("Cards this[%v](%v) Not Equal that[%v](%v)", i, this.Cards[i], i, that1.Cards[i])
		}
	}
	return nil
}
func (this *GetCardsByDueDateResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetCardsByDueDateResp)
	if !ok {
		that2, ok := that.(GetCardsByDueDateResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if !this.Cards[i].Equal(that1.Cards[i]) {
			return false
		}
	}
	return true
}
func (this *GetCardsByAssignedToIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetCardsByAssignedToIDReq)
	if !ok {
		that2, ok := that.(GetCardsByAssignedToIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetCardsByAssignedToIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetCardsByAssignedToIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetCardsByAssignedToIDReq but is not nil && this == nil")
	}
	if this.AssignedToID != that1.AssignedToID {
		return fmt.Errorf("AssignedToID this(%v) Not Equal that(%v)", this.AssignedToID, that1.AssignedToID)
	}
	return nil
}
func (this *GetCardsByAssignedToIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetCardsByAssignedToIDReq)
	if !ok {
		that2, ok := that.(GetCardsByAssignedToIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AssignedToID != that1.AssignedToID {
		return false
	}
	return true
}
func (this *GetCardsByAssignedToIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetCardsByAssignedToIDResp)
	if !ok {
		that2, ok := that.(GetCardsByAssignedToIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetCardsByAssignedToIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetCardsByAssignedToIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetCardsByAssignedToIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if len(this.Cards) != len(that1.Cards) {
		return fmt.Errorf("Cards this(%v) Not Equal that(%v)", len(this.Cards), len(that1.Cards))
	}
	for i := range this.Cards {
		if !this.Cards[i].Equal(that1.Cards[i]) {
			return fmt.Errorf("Cards this[%v](%v) Not Equal that[%v](%v)", i, this.Cards[i], i, that1.Cards[i])
		}
	}
	return nil
}
func (this *GetCardsByAssignedToIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetCardsByAssignedToIDResp)
	if !ok {
		that2, ok := that.(GetCardsByAssignedToIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if !this.Cards[i].Equal(that1.Cards[i]) {
			return false
		}
	}
	return true
}
func (this *GetCardsByCreatorIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetCardsByCreatorIDReq)
	if !ok {
		that2, ok := that.(GetCardsByCreatorIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetCardsByCreatorIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetCardsByCreatorIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetCardsByCreatorIDReq but is not nil && this == nil")
	}
	return nil
}
func (this *GetCardsByCreatorIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetCardsByCreatorIDReq)
	if !ok {
		that2, ok := that.(GetCardsByCreatorIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetCardsByCreatorIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetCardsByCreatorIDResp)
	if !ok {
		that2, ok := that.(GetCardsByCreatorIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetCardsByCreatorIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetCardsByCreatorIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetCardsByCreatorIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if len(this.Cards) != len(that1.Cards) {
		return fmt.Errorf("Cards this(%v) Not Equal that(%v)", len(this.Cards), len(that1.Cards))
	}
	for i := range this.Cards {
		if !this.Cards[i].Equal(that1.Cards[i]) {
			return fmt.Errorf("Cards this[%v](%v) Not Equal that[%v](%v)", i, this.Cards[i], i, that1.Cards[i])
		}
	}
	return nil
}
func (this *GetCardsByCreatorIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetCardsByCreatorIDResp)
	if !ok {
		that2, ok := that.(GetCardsByCreatorIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if !this.Cards[i].Equal(that1.Cards[i]) {
			return false
		}
	}
	return true
}
func (this *GetCardsByColumnIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetCardsByColumnIDReq)
	if !ok {
		that2, ok := that.(GetCardsByColumnIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetCardsByColumnIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetCardsByColumnIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetCardsByColumnIDReq but is not nil && this == nil")
	}
	if this.ColumnID != that1.ColumnID {
		return fmt.Errorf("ColumnID this(%v) Not Equal that(%v)", this.ColumnID, that1.ColumnID)
	}
	return nil
}
func (this *GetCardsByColumnIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetCardsByColumnIDReq)
	if !ok {
		that2, ok := that.(GetCardsByColumnIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	return true
}
func (this *GetCardsByColumnIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetCardsByColumnIDResp)
	if !ok {
		that2, ok := that.(GetCardsByColumnIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetCardsByColumnIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetCardsByColumnIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetCardsByColumnIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if len(this.Cards) != len(that1.Cards) {
		return fmt.Errorf("Cards this(%v) Not Equal that(%v)", len(this.Cards), len(that1.Cards))
	}
	for i := range this.Cards {
		if !this.Cards[i].Equal(that1.Cards[i]) {
			return fmt.Errorf("Cards this[%v](%v) Not Equal that[%v](%v)", i, this.Cards[i], i, that1.Cards[i])
		}
	}
	return nil
}
func (this *GetCardsByColumnIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetCardsByColumnIDResp)
	if !ok {
		that2, ok := that.(GetCardsByColumnIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if !this.Cards[i].Equal(that1.Cards[i]) {
			return false
		}
	}
	return true
}
func (this *UpdateCardByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateCardByIDReq)
	if !ok {
		that2, ok := that.(UpdateCardByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UpdateCardByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateCardByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateCardByIDReq but is not nil && this == nil")
	}
	if this.CardID != that1.CardID {
		return fmt.Errorf("CardID this(%v) Not Equal that(%v)", this.CardID, that1.CardID)
	}
	if !this.UpdateCard.Equal(that1.UpdateCard) {
		return fmt.Errorf("UpdateCard this(%v) Not Equal that(%v)", this.UpdateCard, that1.UpdateCard)
	}
	return nil
}
func (this *UpdateCardByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateCardByIDReq)
	if !ok {
		that2, ok := that.(UpdateCardByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CardID != that1.CardID {
		return false
	}
	if !this.UpdateCard.Equal(that1.UpdateCard) {
		return false
	}
	return true
}
func (this *UpdateCardByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateCardByIDResp)
	if !ok {
		that2, ok := that.(UpdateCardByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UpdateCardByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateCardByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateCardByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *UpdateCardByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateCardByIDResp)
	if !ok {
		that2, ok := that.(UpdateCardByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *DeleteCardByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeleteCardByIDReq)
	if !ok {
		that2, ok := that.(DeleteCardByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeleteCardByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeleteCardByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeleteCardByIDReq but is not nil && this == nil")
	}
	if this.CardID != that1.CardID {
		return fmt.Errorf("CardID this(%v) Not Equal that(%v)", this.CardID, that1.CardID)
	}
	return nil
}
func (this *DeleteCardByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteCardByIDReq)
	if !ok {
		that2, ok := that.(DeleteCardByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CardID != that1.CardID {
		return false
	}
	return true
}
func (this *DeleteCardByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeleteCardByIDResp)
	if !ok {
		that2, ok := that.(DeleteCardByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeleteCardByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeleteCardByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeleteCardByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *DeleteCardByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteCardByIDResp)
	if !ok {
		that2, ok := that.(DeleteCardByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *CreateColumnReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CreateColumnReq)
	if !ok {
		that2, ok := that.(CreateColumnReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CreateColumnReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CreateColumnReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CreateColumnReq but is not nil && this == nil")
	}
	if !this.CreateColumn.Equal(that1.CreateColumn) {
		return fmt.Errorf("CreateColumn this(%v) Not Equal that(%v)", this.CreateColumn, that1.CreateColumn)
	}
	return nil
}
func (this *CreateColumnReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateColumnReq)
	if !ok {
		that2, ok := that.(CreateColumnReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CreateColumn.Equal(that1.CreateColumn) {
		return false
	}
	return true
}
func (this *CreateColumnResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CreateColumnResp)
	if !ok {
		that2, ok := that.(CreateColumnResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CreateColumnResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CreateColumnResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CreateColumnResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *CreateColumnResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateColumnResp)
	if !ok {
		that2, ok := that.(CreateColumnResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *GetColumnByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetColumnByIDReq)
	if !ok {
		that2, ok := that.(GetColumnByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetColumnByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetColumnByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetColumnByIDReq but is not nil && this == nil")
	}
	if this.ColumnID != that1.ColumnID {
		return fmt.Errorf("ColumnID this(%v) Not Equal that(%v)", this.ColumnID, that1.ColumnID)
	}
	return nil
}
func (this *GetColumnByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetColumnByIDReq)
	if !ok {
		that2, ok := that.(GetColumnByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	return true
}
func (this *GetColumnByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetColumnByIDResp)
	if !ok {
		that2, ok := that.(GetColumnByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetColumnByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetColumnByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetColumnByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if !this.Column.Equal(that1.Column) {
		return fmt.Errorf("Column this(%v) Not Equal that(%v)", this.Column, that1.Column)
	}
	return nil
}
func (this *GetColumnByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetColumnByIDResp)
	if !ok {
		that2, ok := that.(GetColumnByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if !this.Column.Equal(that1.Column) {
		return false
	}
	return true
}
func (this *GetColumnsByTitleReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetColumnsByTitleReq)
	if !ok {
		that2, ok := that.(GetColumnsByTitleReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetColumnsByTitleReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetColumnsByTitleReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetColumnsByTitleReq but is not nil && this == nil")
	}
	if this.Title != that1.Title {
		return fmt.Errorf("Title this(%v) Not Equal that(%v)", this.Title, that1.Title)
	}
	return nil
}
func (this *GetColumnsByTitleReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetColumnsByTitleReq)
	if !ok {
		that2, ok := that.(GetColumnsByTitleReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	return true
}
func (this *GetColumnsByTitleResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetColumnsByTitleResp)
	if !ok {
		that2, ok := that.(GetColumnsByTitleResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetColumnsByTitleResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetColumnsByTitleResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetColumnsByTitleResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if len(this.Columns) != len(that1.Columns) {
		return fmt.Errorf("Columns this(%v) Not Equal that(%v)", len(this.Columns), len(that1.Columns))
	}
	for i := range this.Columns {
		if !this.Columns[i].Equal(that1.Columns[i]) {
			return fmt.Errorf("Columns this[%v](%v) Not Equal that[%v](%v)", i, this.Columns[i], i, that1.Columns[i])
		}
	}
	return nil
}
func (this *GetColumnsByTitleResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetColumnsByTitleResp)
	if !ok {
		that2, ok := that.(GetColumnsByTitleResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if !this.Columns[i].Equal(that1.Columns[i]) {
			return false
		}
	}
	return true
}
func (this *GetColumnsByProjectIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetColumnsByProjectIDReq)
	if !ok {
		that2, ok := that.(GetColumnsByProjectIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetColumnsByProjectIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetColumnsByProjectIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetColumnsByProjectIDReq but is not nil && this == nil")
	}
	if this.ProjectID != that1.ProjectID {
		return fmt.Errorf("ProjectID this(%v) Not Equal that(%v)", this.ProjectID, that1.ProjectID)
	}
	return nil
}
func (this *GetColumnsByProjectIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetColumnsByProjectIDReq)
	if !ok {
		that2, ok := that.(GetColumnsByProjectIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProjectID != that1.ProjectID {
		return false
	}
	return true
}
func (this *GetColumnsByProjectIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetColumnsByProjectIDResp)
	if !ok {
		that2, ok := that.(GetColumnsByProjectIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetColumnsByProjectIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetColumnsByProjectIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetColumnsByProjectIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if len(this.Columns) != len(that1.Columns) {
		return fmt.Errorf("Columns this(%v) Not Equal that(%v)", len(this.Columns), len(that1.Columns))
	}
	for i := range this.Columns {
		if !this.Columns[i].Equal(that1.Columns[i]) {
			return fmt.Errorf("Columns this[%v](%v) Not Equal that[%v](%v)", i, this.Columns[i], i, that1.Columns[i])
		}
	}
	return nil
}
func (this *GetColumnsByProjectIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetColumnsByProjectIDResp)
	if !ok {
		that2, ok := that.(GetColumnsByProjectIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if !this.Columns[i].Equal(that1.Columns[i]) {
			return false
		}
	}
	return true
}
func (this *UpdateColumnByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateColumnByIDReq)
	if !ok {
		that2, ok := that.(UpdateColumnByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UpdateColumnByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateColumnByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateColumnByIDReq but is not nil && this == nil")
	}
	if this.ColumnID != that1.ColumnID {
		return fmt.Errorf("ColumnID this(%v) Not Equal that(%v)", this.ColumnID, that1.ColumnID)
	}
	if !this.Column.Equal(that1.Column) {
		return fmt.Errorf("Column this(%v) Not Equal that(%v)", this.Column, that1.Column)
	}
	return nil
}
func (this *UpdateColumnByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateColumnByIDReq)
	if !ok {
		that2, ok := that.(UpdateColumnByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if !this.Column.Equal(that1.Column) {
		return false
	}
	return true
}
func (this *UpdateColumnByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateColumnByIDResp)
	if !ok {
		that2, ok := that.(UpdateColumnByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UpdateColumnByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateColumnByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateColumnByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *UpdateColumnByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateColumnByIDResp)
	if !ok {
		that2, ok := that.(UpdateColumnByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *DeleteColumnByIDReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeleteColumnByIDReq)
	if !ok {
		that2, ok := that.(DeleteColumnByIDReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeleteColumnByIDReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeleteColumnByIDReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeleteColumnByIDReq but is not nil && this == nil")
	}
	if this.ColumnID != that1.ColumnID {
		return fmt.Errorf("ColumnID this(%v) Not Equal that(%v)", this.ColumnID, that1.ColumnID)
	}
	return nil
}
func (this *DeleteColumnByIDReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteColumnByIDReq)
	if !ok {
		that2, ok := that.(DeleteColumnByIDReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	return true
}
func (this *DeleteColumnByIDResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeleteColumnByIDResp)
	if !ok {
		that2, ok := that.(DeleteColumnByIDResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeleteColumnByIDResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeleteColumnByIDResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeleteColumnByIDResp but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *DeleteColumnByIDResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteColumnByIDResp)
	if !ok {
		that2, ok := that.(DeleteColumnByIDResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *CreateCardReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ccmanrpc.CreateCardReq{")
	if this.CreateCard != nil {
		s = append(s, "CreateCard: "+fmt.Sprintf("%#v", this.CreateCard)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateCardResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ccmanrpc.CreateCardResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCardByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ccmanrpc.GetCardByIDReq{")
	s = append(s, "CardID: "+fmt.Sprintf("%#v", this.CardID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCardByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ccmanrpc.GetCardByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.ResCard != nil {
		s = append(s, "ResCard: "+fmt.Sprintf("%#v", this.ResCard)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCardsByDueDateReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ccmanrpc.GetCardsByDueDateReq{")
	if this.DueDate != nil {
		s = append(s, "DueDate: "+fmt.Sprintf("%#v", this.DueDate)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCardsByDueDateResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ccmanrpc.GetCardsByDueDateResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Cards != nil {
		s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCardsByAssignedToIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ccmanrpc.GetCardsByAssignedToIDReq{")
	s = append(s, "AssignedToID: "+fmt.Sprintf("%#v", this.AssignedToID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCardsByAssignedToIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ccmanrpc.GetCardsByAssignedToIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Cards != nil {
		s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCardsByCreatorIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&ccmanrpc.GetCardsByCreatorIDReq{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCardsByCreatorIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ccmanrpc.GetCardsByCreatorIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Cards != nil {
		s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCardsByColumnIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ccmanrpc.GetCardsByColumnIDReq{")
	s = append(s, "ColumnID: "+fmt.Sprintf("%#v", this.ColumnID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCardsByColumnIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ccmanrpc.GetCardsByColumnIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Cards != nil {
		s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateCardByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ccmanrpc.UpdateCardByIDReq{")
	s = append(s, "CardID: "+fmt.Sprintf("%#v", this.CardID)+",\n")
	if this.UpdateCard != nil {
		s = append(s, "UpdateCard: "+fmt.Sprintf("%#v", this.UpdateCard)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateCardByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ccmanrpc.UpdateCardByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteCardByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ccmanrpc.DeleteCardByIDReq{")
	s = append(s, "CardID: "+fmt.Sprintf("%#v", this.CardID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteCardByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ccmanrpc.DeleteCardByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateColumnReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ccmanrpc.CreateColumnReq{")
	if this.CreateColumn != nil {
		s = append(s, "CreateColumn: "+fmt.Sprintf("%#v", this.CreateColumn)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateColumnResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ccmanrpc.CreateColumnResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetColumnByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ccmanrpc.GetColumnByIDReq{")
	s = append(s, "ColumnID: "+fmt.Sprintf("%#v", this.ColumnID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetColumnByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ccmanrpc.GetColumnByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Column != nil {
		s = append(s, "Column: "+fmt.Sprintf("%#v", this.Column)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetColumnsByTitleReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ccmanrpc.GetColumnsByTitleReq{")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetColumnsByTitleResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ccmanrpc.GetColumnsByTitleResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Columns != nil {
		s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetColumnsByProjectIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ccmanrpc.GetColumnsByProjectIDReq{")
	s = append(s, "ProjectID: "+fmt.Sprintf("%#v", this.ProjectID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetColumnsByProjectIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ccmanrpc.GetColumnsByProjectIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Columns != nil {
		s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateColumnByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ccmanrpc.UpdateColumnByIDReq{")
	s = append(s, "ColumnID: "+fmt.Sprintf("%#v", this.ColumnID)+",\n")
	if this.Column != nil {
		s = append(s, "Column: "+fmt.Sprintf("%#v", this.Column)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateColumnByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ccmanrpc.UpdateColumnByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteColumnByIDReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ccmanrpc.DeleteColumnByIDReq{")
	s = append(s, "ColumnID: "+fmt.Sprintf("%#v", this.ColumnID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteColumnByIDResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ccmanrpc.DeleteColumnByIDResp{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCcmanService(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CCManagerClient is the client API for CCManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CCManagerClient interface {
	CreateCard(ctx context.Context, in *CreateCardReq, opts ...grpc.CallOption) (*CreateCardResp, error)
	GetCardByID(ctx context.Context, in *GetCardByIDReq, opts ...grpc.CallOption) (*GetCardByIDResp, error)
	GetCardsByDueDate(ctx context.Context, in *GetCardsByDueDateReq, opts ...grpc.CallOption) (*GetCardsByDueDateResp, error)
	GetCardsByAssignedToID(ctx context.Context, in *GetCardsByAssignedToIDReq, opts ...grpc.CallOption) (*GetCardsByAssignedToIDResp, error)
	GetCardsByCreatorID(ctx context.Context, in *GetCardsByCreatorIDReq, opts ...grpc.CallOption) (*GetCardsByCreatorIDResp, error)
	GetCardsByColumnID(ctx context.Context, in *GetCardsByColumnIDReq, opts ...grpc.CallOption) (*GetCardsByColumnIDResp, error)
	UpdateCardByID(ctx context.Context, in *UpdateCardByIDReq, opts ...grpc.CallOption) (*UpdateCardByIDResp, error)
	DeleteCardByID(ctx context.Context, in *DeleteCardByIDReq, opts ...grpc.CallOption) (*DeleteCardByIDResp, error)
	CreateColumn(ctx context.Context, in *CreateColumnReq, opts ...grpc.CallOption) (*CreateColumnResp, error)
	GetColumnByID(ctx context.Context, in *GetColumnByIDReq, opts ...grpc.CallOption) (*GetColumnByIDResp, error)
	GetColumnsByTitle(ctx context.Context, in *GetColumnsByTitleReq, opts ...grpc.CallOption) (*GetColumnsByTitleResp, error)
	GetColumnsByProjectID(ctx context.Context, in *GetColumnsByProjectIDReq, opts ...grpc.CallOption) (*GetColumnsByProjectIDResp, error)
	UpdateColumnByID(ctx context.Context, in *UpdateColumnByIDReq, opts ...grpc.CallOption) (*UpdateColumnByIDResp, error)
	DeleteColumnByID(ctx context.Context, in *DeleteColumnByIDReq, opts ...grpc.CallOption) (*DeleteColumnByIDResp, error)
}

type cCManagerClient struct {
	cc *grpc.ClientConn
}

func NewCCManagerClient(cc *grpc.ClientConn) CCManagerClient {
	return &cCManagerClient{cc}
}

func (c *cCManagerClient) CreateCard(ctx context.Context, in *CreateCardReq, opts ...grpc.CallOption) (*CreateCardResp, error) {
	out := new(CreateCardResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/CreateCard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cCManagerClient) GetCardByID(ctx context.Context, in *GetCardByIDReq, opts ...grpc.CallOption) (*GetCardByIDResp, error) {
	out := new(GetCardByIDResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/GetCardByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cCManagerClient) GetCardsByDueDate(ctx context.Context, in *GetCardsByDueDateReq, opts ...grpc.CallOption) (*GetCardsByDueDateResp, error) {
	out := new(GetCardsByDueDateResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/GetCardsByDueDate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cCManagerClient) GetCardsByAssignedToID(ctx context.Context, in *GetCardsByAssignedToIDReq, opts ...grpc.CallOption) (*GetCardsByAssignedToIDResp, error) {
	out := new(GetCardsByAssignedToIDResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/GetCardsByAssignedToID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cCManagerClient) GetCardsByCreatorID(ctx context.Context, in *GetCardsByCreatorIDReq, opts ...grpc.CallOption) (*GetCardsByCreatorIDResp, error) {
	out := new(GetCardsByCreatorIDResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/GetCardsByCreatorID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cCManagerClient) GetCardsByColumnID(ctx context.Context, in *GetCardsByColumnIDReq, opts ...grpc.CallOption) (*GetCardsByColumnIDResp, error) {
	out := new(GetCardsByColumnIDResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/GetCardsByColumnID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cCManagerClient) UpdateCardByID(ctx context.Context, in *UpdateCardByIDReq, opts ...grpc.CallOption) (*UpdateCardByIDResp, error) {
	out := new(UpdateCardByIDResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/UpdateCardByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cCManagerClient) DeleteCardByID(ctx context.Context, in *DeleteCardByIDReq, opts ...grpc.CallOption) (*DeleteCardByIDResp, error) {
	out := new(DeleteCardByIDResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/DeleteCardByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cCManagerClient) CreateColumn(ctx context.Context, in *CreateColumnReq, opts ...grpc.CallOption) (*CreateColumnResp, error) {
	out := new(CreateColumnResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/CreateColumn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cCManagerClient) GetColumnByID(ctx context.Context, in *GetColumnByIDReq, opts ...grpc.CallOption) (*GetColumnByIDResp, error) {
	out := new(GetColumnByIDResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/GetColumnByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cCManagerClient) GetColumnsByTitle(ctx context.Context, in *GetColumnsByTitleReq, opts ...grpc.CallOption) (*GetColumnsByTitleResp, error) {
	out := new(GetColumnsByTitleResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/GetColumnsByTitle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cCManagerClient) GetColumnsByProjectID(ctx context.Context, in *GetColumnsByProjectIDReq, opts ...grpc.CallOption) (*GetColumnsByProjectIDResp, error) {
	out := new(GetColumnsByProjectIDResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/GetColumnsByProjectID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cCManagerClient) UpdateColumnByID(ctx context.Context, in *UpdateColumnByIDReq, opts ...grpc.CallOption) (*UpdateColumnByIDResp, error) {
	out := new(UpdateColumnByIDResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/UpdateColumnByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cCManagerClient) DeleteColumnByID(ctx context.Context, in *DeleteColumnByIDReq, opts ...grpc.CallOption) (*DeleteColumnByIDResp, error) {
	out := new(DeleteColumnByIDResp)
	err := c.cc.Invoke(ctx, "/ccmanrpc.CCManager/DeleteColumnByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CCManagerServer is the server API for CCManager service.
type CCManagerServer interface {
	CreateCard(context.Context, *CreateCardReq) (*CreateCardResp, error)
	GetCardByID(context.Context, *GetCardByIDReq) (*GetCardByIDResp, error)
	GetCardsByDueDate(context.Context, *GetCardsByDueDateReq) (*GetCardsByDueDateResp, error)
	GetCardsByAssignedToID(context.Context, *GetCardsByAssignedToIDReq) (*GetCardsByAssignedToIDResp, error)
	GetCardsByCreatorID(context.Context, *GetCardsByCreatorIDReq) (*GetCardsByCreatorIDResp, error)
	GetCardsByColumnID(context.Context, *GetCardsByColumnIDReq) (*GetCardsByColumnIDResp, error)
	UpdateCardByID(context.Context, *UpdateCardByIDReq) (*UpdateCardByIDResp, error)
	DeleteCardByID(context.Context, *DeleteCardByIDReq) (*DeleteCardByIDResp, error)
	CreateColumn(context.Context, *CreateColumnReq) (*CreateColumnResp, error)
	GetColumnByID(context.Context, *GetColumnByIDReq) (*GetColumnByIDResp, error)
	GetColumnsByTitle(context.Context, *GetColumnsByTitleReq) (*GetColumnsByTitleResp, error)
	GetColumnsByProjectID(context.Context, *GetColumnsByProjectIDReq) (*GetColumnsByProjectIDResp, error)
	UpdateColumnByID(context.Context, *UpdateColumnByIDReq) (*UpdateColumnByIDResp, error)
	DeleteColumnByID(context.Context, *DeleteColumnByIDReq) (*DeleteColumnByIDResp, error)
}

// UnimplementedCCManagerServer can be embedded to have forward compatible implementations.
type UnimplementedCCManagerServer struct {
}

func (*UnimplementedCCManagerServer) CreateCard(ctx context.Context, req *CreateCardReq) (*CreateCardResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCard not implemented")
}
func (*UnimplementedCCManagerServer) GetCardByID(ctx context.Context, req *GetCardByIDReq) (*GetCardByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCardByID not implemented")
}
func (*UnimplementedCCManagerServer) GetCardsByDueDate(ctx context.Context, req *GetCardsByDueDateReq) (*GetCardsByDueDateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCardsByDueDate not implemented")
}
func (*UnimplementedCCManagerServer) GetCardsByAssignedToID(ctx context.Context, req *GetCardsByAssignedToIDReq) (*GetCardsByAssignedToIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCardsByAssignedToID not implemented")
}
func (*UnimplementedCCManagerServer) GetCardsByCreatorID(ctx context.Context, req *GetCardsByCreatorIDReq) (*GetCardsByCreatorIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCardsByCreatorID not implemented")
}
func (*UnimplementedCCManagerServer) GetCardsByColumnID(ctx context.Context, req *GetCardsByColumnIDReq) (*GetCardsByColumnIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCardsByColumnID not implemented")
}
func (*UnimplementedCCManagerServer) UpdateCardByID(ctx context.Context, req *UpdateCardByIDReq) (*UpdateCardByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCardByID not implemented")
}
func (*UnimplementedCCManagerServer) DeleteCardByID(ctx context.Context, req *DeleteCardByIDReq) (*DeleteCardByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCardByID not implemented")
}
func (*UnimplementedCCManagerServer) CreateColumn(ctx context.Context, req *CreateColumnReq) (*CreateColumnResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateColumn not implemented")
}
func (*UnimplementedCCManagerServer) GetColumnByID(ctx context.Context, req *GetColumnByIDReq) (*GetColumnByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetColumnByID not implemented")
}
func (*UnimplementedCCManagerServer) GetColumnsByTitle(ctx context.Context, req *GetColumnsByTitleReq) (*GetColumnsByTitleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetColumnsByTitle not implemented")
}
func (*UnimplementedCCManagerServer) GetColumnsByProjectID(ctx context.Context, req *GetColumnsByProjectIDReq) (*GetColumnsByProjectIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetColumnsByProjectID not implemented")
}
func (*UnimplementedCCManagerServer) UpdateColumnByID(ctx context.Context, req *UpdateColumnByIDReq) (*UpdateColumnByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateColumnByID not implemented")
}
func (*UnimplementedCCManagerServer) DeleteColumnByID(ctx context.Context, req *DeleteColumnByIDReq) (*DeleteColumnByIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteColumnByID not implemented")
}

func RegisterCCManagerServer(s *grpc.Server, srv CCManagerServer) {
	s.RegisterService(&_CCManager_serviceDesc, srv)
}

func _CCManager_CreateCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).CreateCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/CreateCard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).CreateCard(ctx, req.(*CreateCardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CCManager_GetCardByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCardByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).GetCardByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/GetCardByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).GetCardByID(ctx, req.(*GetCardByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CCManager_GetCardsByDueDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCardsByDueDateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).GetCardsByDueDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/GetCardsByDueDate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).GetCardsByDueDate(ctx, req.(*GetCardsByDueDateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CCManager_GetCardsByAssignedToID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCardsByAssignedToIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).GetCardsByAssignedToID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/GetCardsByAssignedToID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).GetCardsByAssignedToID(ctx, req.(*GetCardsByAssignedToIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CCManager_GetCardsByCreatorID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCardsByCreatorIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).GetCardsByCreatorID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/GetCardsByCreatorID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).GetCardsByCreatorID(ctx, req.(*GetCardsByCreatorIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CCManager_GetCardsByColumnID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCardsByColumnIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).GetCardsByColumnID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/GetCardsByColumnID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).GetCardsByColumnID(ctx, req.(*GetCardsByColumnIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CCManager_UpdateCardByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCardByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).UpdateCardByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/UpdateCardByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).UpdateCardByID(ctx, req.(*UpdateCardByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CCManager_DeleteCardByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCardByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).DeleteCardByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/DeleteCardByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).DeleteCardByID(ctx, req.(*DeleteCardByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CCManager_CreateColumn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateColumnReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).CreateColumn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/CreateColumn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).CreateColumn(ctx, req.(*CreateColumnReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CCManager_GetColumnByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetColumnByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).GetColumnByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/GetColumnByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).GetColumnByID(ctx, req.(*GetColumnByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CCManager_GetColumnsByTitle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetColumnsByTitleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).GetColumnsByTitle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/GetColumnsByTitle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).GetColumnsByTitle(ctx, req.(*GetColumnsByTitleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CCManager_GetColumnsByProjectID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetColumnsByProjectIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).GetColumnsByProjectID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/GetColumnsByProjectID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).GetColumnsByProjectID(ctx, req.(*GetColumnsByProjectIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CCManager_UpdateColumnByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateColumnByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).UpdateColumnByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/UpdateColumnByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).UpdateColumnByID(ctx, req.(*UpdateColumnByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CCManager_DeleteColumnByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteColumnByIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CCManagerServer).DeleteColumnByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmanrpc.CCManager/DeleteColumnByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CCManagerServer).DeleteColumnByID(ctx, req.(*DeleteColumnByIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _CCManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ccmanrpc.CCManager",
	HandlerType: (*CCManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCard",
			Handler:    _CCManager_CreateCard_Handler,
		},
		{
			MethodName: "GetCardByID",
			Handler:    _CCManager_GetCardByID_Handler,
		},
		{
			MethodName: "GetCardsByDueDate",
			Handler:    _CCManager_GetCardsByDueDate_Handler,
		},
		{
			MethodName: "GetCardsByAssignedToID",
			Handler:    _CCManager_GetCardsByAssignedToID_Handler,
		},
		{
			MethodName: "GetCardsByCreatorID",
			Handler:    _CCManager_GetCardsByCreatorID_Handler,
		},
		{
			MethodName: "GetCardsByColumnID",
			Handler:    _CCManager_GetCardsByColumnID_Handler,
		},
		{
			MethodName: "UpdateCardByID",
			Handler:    _CCManager_UpdateCardByID_Handler,
		},
		{
			MethodName: "DeleteCardByID",
			Handler:    _CCManager_DeleteCardByID_Handler,
		},
		{
			MethodName: "CreateColumn",
			Handler:    _CCManager_CreateColumn_Handler,
		},
		{
			MethodName: "GetColumnByID",
			Handler:    _CCManager_GetColumnByID_Handler,
		},
		{
			MethodName: "GetColumnsByTitle",
			Handler:    _CCManager_GetColumnsByTitle_Handler,
		},
		{
			MethodName: "GetColumnsByProjectID",
			Handler:    _CCManager_GetColumnsByProjectID_Handler,
		},
		{
			MethodName: "UpdateColumnByID",
			Handler:    _CCManager_UpdateColumnByID_Handler,
		},
		{
			MethodName: "DeleteColumnByID",
			Handler:    _CCManager_DeleteColumnByID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/thanhpp/prom/pkg/ccmanrpc/ccmanService.proto",
}

func (m *CreateCardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateCardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateCardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreateCard != nil {
		{
			size, err := m.CreateCard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCcmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateCardResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateCardResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateCardResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCardByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCardByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CardID != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.CardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCardByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCardByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResCard != nil {
		{
			size, err := m.ResCard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCcmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCardsByDueDateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardsByDueDateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCardsByDueDateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DueDate != nil {
		{
			size, err := m.DueDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCcmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetCardsByDueDateResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardsByDueDateResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCardsByDueDateResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for iNdEx := len(m.Cards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCcmanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCardsByAssignedToIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardsByAssignedToIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCardsByAssignedToIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssignedToID != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.AssignedToID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCardsByAssignedToIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardsByAssignedToIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCardsByAssignedToIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for iNdEx := len(m.Cards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCcmanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCardsByCreatorIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardsByCreatorIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCardsByCreatorIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetCardsByCreatorIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardsByCreatorIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCardsByCreatorIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for iNdEx := len(m.Cards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCcmanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCardsByColumnIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardsByColumnIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCardsByColumnIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColumnID != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCardsByColumnIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardsByColumnIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCardsByColumnIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for iNdEx := len(m.Cards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCcmanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCardByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCardByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCardByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateCard != nil {
		{
			size, err := m.UpdateCard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCcmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CardID != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.CardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCardByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCardByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCardByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteCardByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCardByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteCardByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CardID != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.CardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteCardByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCardByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteCardByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateColumnReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateColumnReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateColumnReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreateColumn != nil {
		{
			size, err := m.CreateColumn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCcmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateColumnResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateColumnResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateColumnResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetColumnByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetColumnByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetColumnByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColumnID != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetColumnByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetColumnByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetColumnByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Column != nil {
		{
			size, err := m.Column.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCcmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetColumnsByTitleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetColumnsByTitleReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetColumnsByTitleReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetColumnsByTitleResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetColumnsByTitleResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetColumnsByTitleResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCcmanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetColumnsByProjectIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetColumnsByProjectIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetColumnsByProjectIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProjectID != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.ProjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetColumnsByProjectIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetColumnsByProjectIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetColumnsByProjectIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCcmanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateColumnByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateColumnByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateColumnByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Column != nil {
		{
			size, err := m.Column.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCcmanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ColumnID != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateColumnByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateColumnByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateColumnByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteColumnByIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteColumnByIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteColumnByIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColumnID != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteColumnByIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteColumnByIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteColumnByIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcmanService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCcmanService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCcmanService(dAtA []byte, offset int, v uint64) int {
	offset -= sovCcmanService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedCreateCardReq(r randyCcmanService, easy bool) *CreateCardReq {
	this := &CreateCardReq{}
	if r.Intn(5) != 0 {
		this.CreateCard = entity.NewPopulatedCard(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateCardResp(r randyCcmanService, easy bool) *CreateCardResp {
	this := &CreateCardResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetCardByIDReq(r randyCcmanService, easy bool) *GetCardByIDReq {
	this := &GetCardByIDReq{}
	this.CardID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetCardByIDResp(r randyCcmanService, easy bool) *GetCardByIDResp {
	this := &GetCardByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if r.Intn(5) != 0 {
		this.ResCard = entity.NewPopulatedCard(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetCardsByDueDateReq(r randyCcmanService, easy bool) *GetCardsByDueDateReq {
	this := &GetCardsByDueDateReq{}
	if r.Intn(5) != 0 {
		this.DueDate = timerpc.NewPopulatedTime(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetCardsByDueDateResp(r randyCcmanService, easy bool) *GetCardsByDueDateResp {
	this := &GetCardsByDueDateResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if r.Intn(5) != 0 {
		v1 := r.Intn(5)
		this.Cards = make([]*entity.Card, v1)
		for i := 0; i < v1; i++ {
			this.Cards[i] = entity.NewPopulatedCard(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetCardsByAssignedToIDReq(r randyCcmanService, easy bool) *GetCardsByAssignedToIDReq {
	this := &GetCardsByAssignedToIDReq{}
	this.AssignedToID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetCardsByAssignedToIDResp(r randyCcmanService, easy bool) *GetCardsByAssignedToIDResp {
	this := &GetCardsByAssignedToIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if r.Intn(5) != 0 {
		v2 := r.Intn(5)
		this.Cards = make([]*entity.Card, v2)
		for i := 0; i < v2; i++ {
			this.Cards[i] = entity.NewPopulatedCard(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetCardsByCreatorIDReq(r randyCcmanService, easy bool) *GetCardsByCreatorIDReq {
	this := &GetCardsByCreatorIDReq{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetCardsByCreatorIDResp(r randyCcmanService, easy bool) *GetCardsByCreatorIDResp {
	this := &GetCardsByCreatorIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if r.Intn(5) != 0 {
		v3 := r.Intn(5)
		this.Cards = make([]*entity.Card, v3)
		for i := 0; i < v3; i++ {
			this.Cards[i] = entity.NewPopulatedCard(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetCardsByColumnIDReq(r randyCcmanService, easy bool) *GetCardsByColumnIDReq {
	this := &GetCardsByColumnIDReq{}
	this.ColumnID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetCardsByColumnIDResp(r randyCcmanService, easy bool) *GetCardsByColumnIDResp {
	this := &GetCardsByColumnIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if r.Intn(5) != 0 {
		v4 := r.Intn(5)
		this.Cards = make([]*entity.Card, v4)
		for i := 0; i < v4; i++ {
			this.Cards[i] = entity.NewPopulatedCard(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateCardByIDReq(r randyCcmanService, easy bool) *UpdateCardByIDReq {
	this := &UpdateCardByIDReq{}
	this.CardID = uint32(r.Uint32())
	if r.Intn(5) != 0 {
		this.UpdateCard = entity.NewPopulatedCard(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateCardByIDResp(r randyCcmanService, easy bool) *UpdateCardByIDResp {
	this := &UpdateCardByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeleteCardByIDReq(r randyCcmanService, easy bool) *DeleteCardByIDReq {
	this := &DeleteCardByIDReq{}
	this.CardID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeleteCardByIDResp(r randyCcmanService, easy bool) *DeleteCardByIDResp {
	this := &DeleteCardByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateColumnReq(r randyCcmanService, easy bool) *CreateColumnReq {
	this := &CreateColumnReq{}
	if r.Intn(5) != 0 {
		this.CreateColumn = entity.NewPopulatedColumn(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateColumnResp(r randyCcmanService, easy bool) *CreateColumnResp {
	this := &CreateColumnResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetColumnByIDReq(r randyCcmanService, easy bool) *GetColumnByIDReq {
	this := &GetColumnByIDReq{}
	this.ColumnID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetColumnByIDResp(r randyCcmanService, easy bool) *GetColumnByIDResp {
	this := &GetColumnByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if r.Intn(5) != 0 {
		this.Column = entity.NewPopulatedColumn(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetColumnsByTitleReq(r randyCcmanService, easy bool) *GetColumnsByTitleReq {
	this := &GetColumnsByTitleReq{}
	this.Title = string(randStringCcmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetColumnsByTitleResp(r randyCcmanService, easy bool) *GetColumnsByTitleResp {
	this := &GetColumnsByTitleResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if r.Intn(5) != 0 {
		v5 := r.Intn(5)
		this.Columns = make([]*entity.Column, v5)
		for i := 0; i < v5; i++ {
			this.Columns[i] = entity.NewPopulatedColumn(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetColumnsByProjectIDReq(r randyCcmanService, easy bool) *GetColumnsByProjectIDReq {
	this := &GetColumnsByProjectIDReq{}
	this.ProjectID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetColumnsByProjectIDResp(r randyCcmanService, easy bool) *GetColumnsByProjectIDResp {
	this := &GetColumnsByProjectIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if r.Intn(5) != 0 {
		v6 := r.Intn(5)
		this.Columns = make([]*entity.Column, v6)
		for i := 0; i < v6; i++ {
			this.Columns[i] = entity.NewPopulatedColumn(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateColumnByIDReq(r randyCcmanService, easy bool) *UpdateColumnByIDReq {
	this := &UpdateColumnByIDReq{}
	this.ColumnID = uint32(r.Uint32())
	if r.Intn(5) != 0 {
		this.Column = entity.NewPopulatedColumn(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateColumnByIDResp(r randyCcmanService, easy bool) *UpdateColumnByIDResp {
	this := &UpdateColumnByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeleteColumnByIDReq(r randyCcmanService, easy bool) *DeleteColumnByIDReq {
	this := &DeleteColumnByIDReq{}
	this.ColumnID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeleteColumnByIDResp(r randyCcmanService, easy bool) *DeleteColumnByIDResp {
	this := &DeleteColumnByIDResp{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Message = string(randStringCcmanService(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyCcmanService interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneCcmanService(r randyCcmanService) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringCcmanService(r randyCcmanService) string {
	v7 := r.Intn(100)
	tmps := make([]rune, v7)
	for i := 0; i < v7; i++ {
		tmps[i] = randUTF8RuneCcmanService(r)
	}
	return string(tmps)
}
func randUnrecognizedCcmanService(r randyCcmanService, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldCcmanService(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldCcmanService(dAtA []byte, r randyCcmanService, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateCcmanService(dAtA, uint64(key))
		v8 := r.Int63()
		if r.Intn(2) == 0 {
			v8 *= -1
		}
		dAtA = encodeVarintPopulateCcmanService(dAtA, uint64(v8))
	case 1:
		dAtA = encodeVarintPopulateCcmanService(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateCcmanService(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateCcmanService(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateCcmanService(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateCcmanService(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *CreateCardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateCard != nil {
		l = m.CreateCard.Size()
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func (m *CreateCardResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func (m *GetCardByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardID != 0 {
		n += 1 + sovCcmanService(uint64(m.CardID))
	}
	return n
}

func (m *GetCardByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	if m.ResCard != nil {
		l = m.ResCard.Size()
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func (m *GetCardsByDueDateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DueDate != nil {
		l = m.DueDate.Size()
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func (m *GetCardsByDueDateResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovCcmanService(uint64(l))
		}
	}
	return n
}

func (m *GetCardsByAssignedToIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AssignedToID != 0 {
		n += 1 + sovCcmanService(uint64(m.AssignedToID))
	}
	return n
}

func (m *GetCardsByAssignedToIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovCcmanService(uint64(l))
		}
	}
	return n
}

func (m *GetCardsByCreatorIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetCardsByCreatorIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovCcmanService(uint64(l))
		}
	}
	return n
}

func (m *GetCardsByColumnIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnID != 0 {
		n += 1 + sovCcmanService(uint64(m.ColumnID))
	}
	return n
}

func (m *GetCardsByColumnIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovCcmanService(uint64(l))
		}
	}
	return n
}

func (m *UpdateCardByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardID != 0 {
		n += 1 + sovCcmanService(uint64(m.CardID))
	}
	if m.UpdateCard != nil {
		l = m.UpdateCard.Size()
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func (m *UpdateCardByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func (m *DeleteCardByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardID != 0 {
		n += 1 + sovCcmanService(uint64(m.CardID))
	}
	return n
}

func (m *DeleteCardByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func (m *CreateColumnReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateColumn != nil {
		l = m.CreateColumn.Size()
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func (m *CreateColumnResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func (m *GetColumnByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnID != 0 {
		n += 1 + sovCcmanService(uint64(m.ColumnID))
	}
	return n
}

func (m *GetColumnByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	if m.Column != nil {
		l = m.Column.Size()
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func (m *GetColumnsByTitleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func (m *GetColumnsByTitleResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovCcmanService(uint64(l))
		}
	}
	return n
}

func (m *GetColumnsByProjectIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectID != 0 {
		n += 1 + sovCcmanService(uint64(m.ProjectID))
	}
	return n
}

func (m *GetColumnsByProjectIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovCcmanService(uint64(l))
		}
	}
	return n
}

func (m *UpdateColumnByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnID != 0 {
		n += 1 + sovCcmanService(uint64(m.ColumnID))
	}
	if m.Column != nil {
		l = m.Column.Size()
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func (m *UpdateColumnByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func (m *DeleteColumnByIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnID != 0 {
		n += 1 + sovCcmanService(uint64(m.ColumnID))
	}
	return n
}

func (m *DeleteColumnByIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCcmanService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcmanService(uint64(l))
	}
	return n
}

func sovCcmanService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCcmanService(x uint64) (n int) {
	return sovCcmanService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreateCardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateCard == nil {
				m.CreateCard = &entity.Card{}
			}
			if err := m.CreateCard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCardResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCardResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCardResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardID", wireType)
			}
			m.CardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResCard == nil {
				m.ResCard = &entity.Card{}
			}
			if err := m.ResCard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardsByDueDateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardsByDueDateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardsByDueDateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DueDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DueDate == nil {
				m.DueDate = &timerpc.Time{}
			}
			if err := m.DueDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardsByDueDateResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardsByDueDateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardsByDueDateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &entity.Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardsByAssignedToIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardsByAssignedToIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardsByAssignedToIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedToID", wireType)
			}
			m.AssignedToID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignedToID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardsByAssignedToIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardsByAssignedToIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardsByAssignedToIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &entity.Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardsByCreatorIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardsByCreatorIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardsByCreatorIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardsByCreatorIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardsByCreatorIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardsByCreatorIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &entity.Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardsByColumnIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardsByColumnIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardsByColumnIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardsByColumnIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardsByColumnIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardsByColumnIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &entity.Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCardByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCardByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCardByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardID", wireType)
			}
			m.CardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateCard == nil {
				m.UpdateCard = &entity.Card{}
			}
			if err := m.UpdateCard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCardByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCardByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCardByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCardByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCardByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCardByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardID", wireType)
			}
			m.CardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCardByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCardByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCardByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateColumnReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateColumnReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateColumnReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateColumn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateColumn == nil {
				m.CreateColumn = &entity.Column{}
			}
			if err := m.CreateColumn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateColumnResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateColumnResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateColumnResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetColumnByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetColumnByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetColumnByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetColumnByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetColumnByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetColumnByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Column == nil {
				m.Column = &entity.Column{}
			}
			if err := m.Column.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetColumnsByTitleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetColumnsByTitleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetColumnsByTitleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetColumnsByTitleResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetColumnsByTitleResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetColumnsByTitleResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &entity.Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetColumnsByProjectIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetColumnsByProjectIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetColumnsByProjectIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectID", wireType)
			}
			m.ProjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetColumnsByProjectIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetColumnsByProjectIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetColumnsByProjectIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &entity.Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateColumnByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateColumnByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateColumnByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Column == nil {
				m.Column = &entity.Column{}
			}
			if err := m.Column.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateColumnByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateColumnByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateColumnByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteColumnByIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteColumnByIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteColumnByIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteColumnByIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteColumnByIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteColumnByIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcmanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcmanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcmanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcmanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCcmanService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCcmanService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCcmanService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCcmanService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCcmanService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCcmanService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCcmanService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCcmanService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCcmanService = fmt.Errorf("proto: unexpected end of group")
)
